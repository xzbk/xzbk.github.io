<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Oracle存储过程与存储函数]]></title>
    <url>%2F2018%2F08%2F22%2FOracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[存储过程和存储函数存储在数据库中供所有用户程序调用的子程序叫做存储过程,存储函数.由于通过out参数,存储过程也可以返回函数值.所以存储过程和存储函数已经没有太大的区别了.而存储函数仍然存在,是由于oracle不断升级,需要实现向下兼容,所以存储函数就一直存留着.区别:是否可以通过return返回函数值.存储函数可以通过return返回函数值,而存储过程不可以. 存储过程1.创建和使用存储过程用create procedure命令建立存储过程和存储函数.语法:123create [or replace] procedure 过程名(参数列表)asPLSQL子程序体; 注意事项:(1)存储过程或者存储函数,只能创建或者替换.(2)参数可以带也可以不带.(3)as相当于PLSQL语句中的declare,用来声明变量,游标等,但是不可以省略. 2.入门案例:不带参数的存储过程:不用带括号12345create or replace procedure sayHelloasbegin dbms_output.put_line('HelloWorld');end; 调用方式:(1) 使用execute;(2) 使用PLSQL语句调用; 3.带参数的存储过程:给指定的员工涨100元工资,并且打印涨前和涨后的薪水:1234567891011create or replace procedure addSal(pempno in emp.empno%type)as pename emp.ename%type; beforesal emp.sal%type; aftersal emp.sal%type;begin select ename,sal into pename,beforesal from emp where empno=pempno; aftersal:=beforesal+100; update emp set sal=aftersal where empno=pempno; dbms_output.put_line('姓名: '||pename||' 涨前工资:'||beforesal||'涨后工资:'||aftersal);end; 注意:(1)要说明,参数是输入参数(in)还是输出参数(out);(2)为保证调用多个存储过程中处在同一个事务中,所以一般不在存储过程或者存储函数中,commit或rollback; 4.调试存储过程:注意:(1) oracle数据库和PLSQL工具都是放在同一个机器上;(2) 在开启调试时,可能会报出权限不够的错误信息,通过下面方式进行授权: 存储函数1.存储函数:函数(Function)为一命名的存储程序,可带参数,并返回一计算值.函数和过程的结构类似,但必须有一个return子句,用于返回函数值. 2.创建存储函数的语法:1234create [or replace] function 函数名(参数列表)return 函数值类型asPLSQL子程序体; 注意事项:(1) 与存储过程注意事项类似,不同的是,必须有个返回值;(2) 参数列表可以有,也可以没有.当没有时,函数名后面不要带括号.123456789create or replace function queryempannal(pempno in number)return numberas psal emp.sal%type; pcomm emp.comm%type;begin select sal,comm into psal,pcomm from emp where empno=pempno; return psal*12+nvl(pcomm,0);end; in和out参数1.概述(1)一般来讲,存储过程和存储函数的区别在于存储函数可以有一个返回值;而存储过程没有返回值.(2)过程和函数都可以通过out指定一个或多个输出参数.我们可以利用out参数,在过程和函数中实现返回多个值.a. 存储过程和存储函数都可以有out参数;b. 存储过程和存储函数都可以有多个out参数;c. 存储过程可以通过out参数来实现返回值;(3)什么时候用存储过程/存储函数?原则:如果只有一个返回值,用存储函数;否则,就用存储过程.12345678create or replace procedure queryempinform(eno in number, pename out varchar2, psal out number, pjob out varchar2 )asbegin select ename,sal,job into pename,psal,pjob from emp where empno=eno;end; 在应用程序中访问存储过程和存储函数1.访问存储过程工具类 JDBCUtils:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package test.oracle.utils;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBCUtils &#123; private static String driver= "oracle.jdbc.OracleDriver" ; private static String url ="jdbc:oracle:thin:@192.168.56.6:1521:orcl" ; private static String user= "scott" ; private static String password= "tiger" ; //注册数据库的驱动 static &#123; try &#123; Class. forName( driver); &#125; catch (ClassNotFoundException e ) &#123; e.printStackTrace(); &#125; &#125; //获取数据库连接 public static Connection getConnection()&#123; try &#123; return DriverManager.getConnection( url , user , password ); &#125; catch (SQLException e ) &#123; e.printStackTrace(); &#125; return null ; &#125; //释放数据库资源 public static void release(Connection conn,Statement sta ,ResultSet rst )&#123; if (conn != null) &#123; try &#123; conn .close(); &#125; catch (SQLException e ) &#123; e.printStackTrace(); &#125; finally &#123; conn =null ; &#125; &#125; if (sta != null) &#123; try &#123; sta .close(); &#125; catch (SQLException e ) &#123; e.printStackTrace(); &#125; finally &#123; sta =null ; &#125; &#125; if (rst != null) &#123; try &#123; rst .close(); &#125; catch (SQLException e ) &#123; e.printStackTrace(); &#125; finally &#123; rst =null ; &#125; &#125; &#125;&#125; TestProcedure.class123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package test.oracle.demo;import java.sql.CallableStatement;import java.sql.Connection;import java.sql.SQLException;import org.junit.Test;import oracle.jdbc.driver.OracleTypes;import test.oracle.utils.JDBCUtils;public class TestProcedure &#123; /* create or replace procedure queryempinform(eno in number, pename out varchar2, psal out number, pjob out varchar2 ) as begin select ename,sal ,job into pename, psal,pjob from emp where empno=eno ; end; / */ @Test public void testProcedure()&#123; /* &#123;call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; */ String sql ="&#123;call queryempinform(?,?,?,?)&#125;" ; Connection conn =null ; CallableStatement sta =null ; try &#123; //获取连接 conn = JDBCUtils.getConnection(); //通过连接创建statement sta =conn .prepareCall( sql); //对于in参数,赋值 sta .setInt(1, 7839); //对于out参数,申明 sta .registerOutParameter(2, OracleTypes. VARCHAR); sta .registerOutParameter(3, OracleTypes. NUMBER); sta .registerOutParameter(4, OracleTypes. VARCHAR); //执行调用 sta .execute(); //取出结果 String name = sta .getString(2); double sal = sta.getDouble(3); String job = sta .getString(4); System. out .println(name +"\t" +sal +"\t" +job ); &#125; catch (SQLException e ) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils. release( conn, sta, null); &#125; &#125;&#125; 2.访问存储函数TestFunction.class1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package test.oracle.demo;import java.sql.CallableStatement;import java.sql.Connection;import java.sql.SQLException;import org.junit.Test;import oracle.jdbc.driver.OracleTypes;import test.oracle.utils.JDBCUtils;public class TestFunction &#123; /* create or replace function queryempannal(pempno in number) return number as psal emp.sal%type; pcomm emp.comm%type; begin select sal,comm into psal, pcomm from emp where empno=pempno ; return psal*12+nvl (pcomm,0); end; */ @Test public void testFunction()&#123; // &#123;?= call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; String sql ="&#123;?= call queryempannal(?)&#125;" ; Connection conn =null ; CallableStatement call =null ; try &#123; //获取数据库连接 conn = JDBCUtils.getConnection(); //通过连接获取statement对象 call =conn .prepareCall( sql); //对于out参数 声明 call .registerOutParameter(1, OracleTypes. NUMBER); //对于in参数 赋值 call .setInt(2, 7839); //执行调用 call .execute(); double income =call .getDouble(1); System. out .println("该员工的年收入为:" +income ); &#125; catch (SQLException e ) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 JDBCUtils. release( conn, call, null); &#125; &#125;&#125; 思考:(1)查询某个员工的所有信息—&gt;out参数太多?(2)查询某个部门中所有员工的所有信息 —&gt;out中返回集合? 在out参数中使用光标,解决上述问题申明包结构 , 包头 ,包体案例:查询某个部门中所有员工的所有信息 包头:12345create or replace package mypackage01 as --使用type关键字,自定义一个光标类型 type empcursor is ref cursor; procedure queryEmpList(dno in number,empList out empcursor);end mypackage01; 包体:123456create or replace package body mypackage01 as procedure queryEmpList(dno in number,empList out empcursor) as begin open empList for select * from emp where deptno=dno; end queryEmpList;end mypackage01; 在控制台,可以使用desc查看程序包的结构:desc mypackage01 在应用中访问包中的存储过程注意:需要带上包名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package test.oracle.demo;import java.sql.CallableStatement;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import org.junit.Test;import oracle.jdbc.driver.OracleCallableStatement;import oracle.jdbc.driver.OracleTypes;import test.oracle.utils.JDBCUtils;public class TestCursor &#123; /* CREATE OR REPLACE PACKAGE MYPACKAGE01 AS type empcursor is ref cursor; procedure queryEmpList( dno in number,empList out empcursor); END MYPACKAGE01; */ @Test public void testCursor()&#123; //&#123;call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; String sql ="&#123;call MYPACKAGE01.queryEmpList(?,?)&#125;" ; Connection conn =null ; CallableStatement call =null ; ResultSet rs= null ; try &#123; //获取数据库连接 conn =JDBCUtils.getConnection(); //通过连接获取statement call =conn .prepareCall( sql); //对于in 参数 赋值 call .setInt(1, 10); //对于out参数 申明 call.registerOutParameter(2, OracleTypes. CURSOR); //执行调用 call .execute(); //获取到指定部门的所有的员工的所有信息 rs=((OracleCallableStatement) call ).getCursor(2); //遍历结果集 while (rs .next()) &#123; //获取员工的编号 姓名 薪水 职位 int empno =rs .getInt( "empno"); String ename =rs .getString( "ename"); double sal =rs .getDouble( "sal"); String job =rs .getString( "job"); System. out .println(empno +"\t" +ename +"\t" +sal +"\t" +job ); &#125; &#125; catch (SQLException e ) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; JDBCUtils. release( conn, call, rs); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java封装树型数据结构]]></title>
    <url>%2F2018%2F08%2F21%2Fjava%E5%B0%81%E8%A3%85%E6%A0%91%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[此方法使用于通过id,pid关联的树形对象.多用于无深度确定的树形结构,常用于联动菜单，多级下拉菜单等数据结构类型的封装树型数据结构应用：TreeView 1.创建树形结构实体对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.group.entity;import java.util.ArrayList;import java.util.List;import java.util.Map;public class Tree&lt;T&gt;&#123; //节点ID，这个节点的唯一标识，通常情况下使用主键或者列的唯一标识都可以。 //这里使用String类型是为了兼容所有的标识，可以是数字类型的字符形式 private String id; //节点的父节点 private String parentId; //这个节点显示的文本 private String text; //是否有父节点 private Boolean haveParent = false; //是否有子节点 private Boolean haveChildrens = false; //默认构造方法 public Tree() &#123; super(); &#125; //本例中使用 public Tree(String id, String parentId, String text, Boolean haveParent, Boolean haveChildrens) &#123; super(); this.id = id; this.parentId = parentId; this.text = text; this.haveParent = haveParent; this.haveChildrens = haveChildrens; &#125; public Tree(String id, String parentId, String text, Boolean haveParent, Boolean haveChildrens, Map&lt;String, Object&gt; attributes) &#123; super(); this.id = id; this.parentId = parentId; this.text = text; this.haveParent = haveParent; this.haveChildrens = haveChildrens; this.attributes = attributes; &#125; //节点子节点 private List&lt;Tree&lt;T&gt;&gt; children = new ArrayList&lt;Tree&lt;T&gt;&gt;(); //节点的额外属性，比如把展开属性和选中属性设置在这里 private Map&lt;String,Object&gt; attributes; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getParentId() &#123; return parentId; &#125; public void setParentId(String parentId) &#123; this.parentId = parentId; &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public List&lt;Tree&lt;T&gt;&gt; getChildren() &#123; return children; &#125; public void setChildren(List&lt;Tree&lt;T&gt;&gt; children) &#123; this.children = children; &#125; public Map&lt;String, Object&gt; getAttributes() &#123; return attributes; &#125; public void setAttributes(Map&lt;String, Object&gt; attributes) &#123; this.attributes = attributes; &#125; public Boolean getHaveParent() &#123; return haveParent; &#125; public void setHaveParent(Boolean haveParent) &#123; this.haveParent = haveParent; &#125; public Boolean getHaveChildrens() &#123; return haveChildrens; &#125; public void setHaveChildrens(Boolean haveChildrens) &#123; this.haveChildrens = haveChildrens; &#125; &#125; 2.使用工具类，将集合转换为树形结构,返回树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.group.util;import java.util.ArrayList;import java.util.List;import com.group.entity.Tree;public class TreeUtil &#123; public static &lt;T&gt; Tree&lt;T&gt; buildToTree(List&lt;Tree&lt;T&gt;&gt; nodes,String rootNodeName) &#123; //如果节点的List为null，就返回null if (nodes == null) &#123; return null; &#125; //没有父节点节点列表 List&lt;Tree&lt;T&gt;&gt; topNodes = new ArrayList&lt;Tree&lt;T&gt;&gt;(); for (Tree&lt;T&gt; children : nodes) &#123; //遍历所有的节点，找出所有的顶级节点，将没有父节点的节点存起来 String pid = children.getParentId(); if (pid == null || "".equals(pid)) &#123; topNodes.add(children); //只要没有父节点，添加后就跳过 continue; &#125; //那么剩下的节点都是有父节点,我们给这个孩子节点找父亲节点 for (Tree&lt;T&gt; parent : nodes) &#123; String id = parent.getId(); if (id != null &amp;&amp; id.equals(pid)) &#123; parent.getChildren().add(children); children.setHaveParent(true); parent.setHaveChildrens(true); //如果找到父节点并将子节点设置到这个父节点上就可以停止继续循环查找 break; &#125; &#125; &#125; //把根节点返回，如果没有父节点不只一个，我们给这些节点创建一个根节点 Tree&lt;T&gt; root = new Tree&lt;T&gt;(); if (topNodes.size() == 1) &#123; root = topNodes.get(0); &#125; else &#123; root.setId("-1"); root.setParentId(""); root.setHaveParent(false); root.setHaveChildrens(true); root.setAttributes(null); root.setChildren(topNodes); root.setText(rootNodeName); &#125; return root; &#125;&#125; 3.测试及结果测试类：12345678910111213141516171819202122232425262728293031323334package com.group.test;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import com.alibaba.fastjson.JSON;import com.group.entity.Tree;import com.group.util.TreeUtilB;public class BuildToThree &#123; public static void main(String[] args) &#123; List&lt;Tree&lt;String&gt;&gt; nodes = new ArrayList&lt;&gt;(); Map mp = new HashMap(); mp.put("student_name", "张三"); mp.put("student_sex", "男"); mp.put("student_age", "22"); //一级节点一 nodes.add(new Tree&lt;String&gt;("1", null, "一级根节点一", false, true , mp)); //一级节点下的两个子节点 nodes.add(new Tree&lt;String&gt;("11", "1", "二级节点一", true, false)); nodes.add(new Tree&lt;String&gt;("12", "1", "二级节点二", true, false)); //一级节点二 nodes.add(new Tree&lt;String&gt;("2", null, "一级节点二", false, true)); //一级节点二下的两个子节点 nodes.add(new Tree&lt;String&gt;("21", "2", "二级节点一", true, false)); nodes.add(new Tree&lt;String&gt;("22", "2", "二级节点二", true, false)); //一级节点三 nodes.add(new Tree&lt;String&gt;("3", null, "一级节点三", false, false)); Tree&lt;String&gt; buildToTree = TreeUtilB.buildToTree(nodes, "没有手动设置根节点"); String treeString = JSON.toJSONString(buildToTree); System.out.println(treeString); &#125;&#125; 结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#123; "children":[ &#123; "attributes":&#123; "student_name":"张三", "student_age":"22", "student_sex":"男" &#125;, "children":[ &#123; "children":[ ], "haveChildrens":false, "haveParent":true, "id":"11", "parentId":"1", "text":"二级节点一" &#125;, &#123; "children":[ ], "haveChildrens":false, "haveParent":true, "id":"12", "parentId":"1", "text":"二级节点二" &#125; ], "haveChildrens":true, "haveParent":false, "id":"1", "text":"一级根节点一" &#125;, &#123; "children":[ &#123; "children":[ ], "haveChildrens":false, "haveParent":true, "id":"21", "parentId":"2", "text":"二级节点一" &#125;, &#123; "children":[ ], "haveChildrens":false, "haveParent":true, "id":"22", "parentId":"2", "text":"二级节点二" &#125; ], "haveChildrens":true, "haveParent":false, "id":"2", "text":"一级节点二" &#125;, &#123; "children":[ ], "haveChildrens":false, "haveParent":false, "id":"3", "text":"一级节点三" &#125; ], "haveChildrens":true, "haveParent":false, "id":"-1", "parentId":"", "text":"没有手动设置根节点"&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM(一)内存分布]]></title>
    <url>%2F2018%2F08%2F19%2FJVM-%E4%B8%80-%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[一、JVM概述①所有的java代码都是在虚拟机中运行的。②一次编译,到处运行。JVM可以和不同的操作系统交互。Java是一门跨平台性语言。 二、JVM、JDK 、JRE区别JDK：(Java Development Kit) 是Java语言的软件开发工具包。JRE：在JDK的安装目录下有一个jre目录，里面有bin和lib两个文件夹，可以认为bin里的就是JVM，lib中则是jvm工作所需要的类库，而jvm和lib合起来称为jre。总结： JDK是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。 JRE是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。 JVM是整个java实现跨平台的最核心的部分，能够运行以Java语言写的程序。 三、JVM内存分布 1.方法区线程共享，存储已经被虚拟机加载的类信息（全限定名，父类全限定名、接口、类、修饰词、方法信息、属性信息…）、常量、静态变量、即时编译器编译后的代码等元数据信息。在方法区有一块非常重要的子内存空间，常量池。 2.堆Java中的堆是用来存储对象本身以及数组的（数组引用是存放在Java栈中）。Java的垃圾回收机制会自动进行处理。因此这部分空间也是GC管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。堆内存不足会抛OutOfMemoryError异常。堆又细分为新生代和老年代，新生代又分为Eden空间、From Survivor空间、To Survivor空间。1234567891011public class TestHeap &#123; private static int i = 1 ; @Test public void heapOverflow()&#123; User[] arr = new User[1024]; for(int i = 0 ; i &lt; 1024 ; i ++)&#123; arr[i] = new User(); &#125; &#125;&#125;//由于堆中存储的是对象，当创建的对象过多时就会发生栈溢出，错误提示：java.lang.OutOfMemoryError: Java heap space 3.栈线程私有的，它的生命周期与线程相同，这块区域是为方法执行是准备的。每个方法执行时，都会创建一个栈帧（一种数据结构），专门用于用来存放方法中的局部变量（成员变量在堆区）如果线程请求的栈深度大于JVM允许的栈深度，将抛出StackOverflowError异常。12345678910111213141516171819202122232425262728293031323334package com.wendao.student; public class Student &#123; private static int age = 18; //age引用和18方法区 private String name = "张三"; //name引用都是放在堆区，张三在常量池。 public void say()&#123; int a = 1;//a 和 1 都存在 say的栈帧里，执行完就回收。 Object b = new Object();//b的引用存在say的栈帧里，实例放在堆。 System.out.println();//当代码执行到这里，栈空间会为这3个方法创建3个栈帧 &#125; public void introduce()&#123; say(); &#125; public static void main(String[] args) &#123; new Student().introduce(); &#125; &#125;public class TestStack &#123; private static int i = 1 ; @Test public void teststack()&#123; call(); &#125; public void call()&#123; System.out.println(i); i ++ ; call(); &#125;&#125;// 由于递归不停的调用自身，方法调用一次就产生一个栈帧，等到内存不够分配，就会出现栈溢出，错误提示：java.lang.StackOverflowError 4.方法区中常量池常量池：分为两种形态，静态常量池和运行时常量池。静态常量池：编译期间产生的内存空间，有些人叫class常量池，class常量池不仅仅存放字符串和数字等字面量数据，还存放类、方法的元数据信息。运行时常量池：则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。相较于静态常量池，运行时常量池更具动态性，静态常量池是死的，基本不会变，但是运行时常量池可以在运行期间通过String类的intern()方法加入新成员。①案例一12345678910111213package com.wendao.student; public class Student &#123; String s1 = "Hello"; String s2 = "Hello"; public void print() &#123; System.out.println(s1 == s2); // true public static void main(String[] args) &#123; new Student().print(); &#125;&#125; ②案例二1234567891011121314package com.wendao.student; public class Student &#123; public void print() &#123; String s1 = "Hello"; String s3 = "Hel" + "lo"; System.out.println(s1 == s3); // true &#125; public static void main(String[] args) &#123; new Student().print(); &#125;&#125; s3虽然是动态拼接出来的字符串，但是在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此s3在class文件中被优化成String s3 = “Hello”;，所以s1 == s3成立。 注：可以用jad反编译查看，默认环境变量中是没有jad命令的，需要下载jad.exe然后放到jdk的bin目录下，点击下载③案例三1234567891011121314package com.wendao.student; public class Student &#123; public void print() &#123; String s1 = "Hello"; String s2 = "Hel" +new String("lo"); System.out.println(s1 == s2); // false &#125; public static void main(String[] args) &#123; new Student().print(); &#125;&#125; s2虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果。④案例四12345678910111213141516package com.wendao.student; public class Student &#123; public void print() &#123; String s1 = "Hello"; String s2 = "Hel"; String s3 = "lo"; String s4 = s2+s3; System.out.println(s1 == s4); // false &#125; public static void main(String[] args) &#123; new Student().print(); &#125;&#125; 虽然s2、s3在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s2、s3作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，所以不做优化，等到运行时，s2、s3拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同。s2+s3这种相加，本质是返回新的StringBuilder对象引用，该引用指向堆区，这也是为什么两个字符串相加会产生新的字符串对象。⑤案例五123456789101112131415package com.wendao.student; public class Student &#123; public void print() &#123; String s1 = "Hello"; String s5 = new String("Hello"); String s6 = s5.intern(); System.out.println(s1 == s6); // true &#125; public static void main(String[] args) &#123; new Student().print(); &#125;&#125; 归功于intern方法，s5的对象在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。官方堆intern方法的解释：当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。⑥案例六1234567891011package com.wendao.student; public class Student &#123; public static void main(String[] args) &#123; String param = "abc"; String param1 = "3abc"; String param2 = param.length() + "abc"; System.out.println(param1==param2);//false &#125; &#125;param1指向常量池，param2指向堆区，即使内容一致，但是引用不一致所以为false ⑦结论： 必须要关注编译期的行为，才能更好的理解常量池。 运行时常量池中的常量，基本来源于各个class文件中的常量池。 程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。 5.堆区的新生代、老年代堆大小 = 新生代 + 老年代。默认下，新生代 ( Young ) = 1/3 的堆空间大小，老年代 ( Old ) = 2/3 的堆空间大小；JDK8中废弃了永久代，替换为Metaspace元空间(本地内存中)①堆区分代的原因优化GC性能。如果没有分代，那么所有的对象都在一块，GC的时候要找到哪些对象没用就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。②新生代特点新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。 默认的，Edem : from Survivor : to Survivor = 8 : 1 : 1； JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间； 新生代GC（minor gc）：指发生在新生代的垃圾回收动作，因为JAVA对象大多数都是朝生夕死（80%对象）的特性，所以minor gc非常频繁，使用复制算法快速的回收。③老年代特点存放”新生代”中生存了较长时间的对象，以及较大的对象。内存空间比新生代要大。垃圾回收的执行频率也会低很多。老年代GC（major gc）———-指发生在老年代的垃圾回收动作，所采用是的标记–整理算法。老年代几乎都是经过survivor熬过来的，它们是不会那么容易“死掉”，因此major gc不会像minor gc那样频繁。④分代/堆模型示例从一个object1来说明其在分代垃圾回收算法中的回收轨迹。1.object1新建，出生于新生代的Eden区域2.第一次minor GC，object1 还存活，移动到Fromsuvivor空间，此时还在新生代。3.第二次minor GC，object1 仍然存活，此时会通过复制算法，将object1复制到ToSuv区域此时object1的年龄age+1。4.第n次minor GC，object1 仍然存活，如果object1年龄为15直接进入老年代。当然还有一种情况要考虑，当object1年龄不足15，也有可能进入老年代。 如果survivor区内很多年龄不太大的对象怎么办呢，大家年龄都不足以进入老年代，但数量太多，survivor也吃不消啊。于是还有一条规则，就是survivor区内所有年龄相同的对象大小总和如果超过survivor区空间的一半，年龄大于等于该年龄的对象都直接进入老年代，不受参数MaxTenuringThreshold参数的限制了。 5.object1存活一段时间后，发现此时object1不可达GcRoots，而且此时老年代空间比率已经超过了阈值,触发了majorGC（也可以认为是fullGC，但具体需要垃圾收集器来联系），此时object1被回收了。fullGC会触发 stop the world。总结:在以上的新生代中，我们有提到对象的age，对象存活于survivor状态下，不会立即晋升为老年代对象，以避免给老生代造成过大的影响，它们必须要满足以下条件才可以晋升： minor gc 之后，存活于survivor 区域的对象的age会+1，当超过（默认）15的时候，转移到老年代。 动态对象，如果survivor空间中相同年龄所有的对象大小的总和大于survivor空间的一半，直接进入老年代。 ⑤GC类型以及促发条件 (1)分类： 针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：Partial GC：并不收集整个GC堆的模式Young GC： 只收集young gen的GCOld GC： 只收集old gen的GC。只有CMS的concurrent collection是这个模式Mixed GC： 收集整个young gen以及部分old gen的GC。只有G1有这个模式Full GC： 收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。 (2)触发条件： Young GC：当young gen中的eden区分配满的时候，或者说剩余内存小于即将new出来的对象的体积的时候触发。Old GC： 当old gen区域分配满的时候Full GC： 当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Httpclient的使用]]></title>
    <url>%2F2018%2F08%2F16%2FHttpclient%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.1&nbsp;Httpclient的使用1.1.1&nbsp;什么是httpclientHttpClient 是 Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。下载地址：http://hc.apache.org/&nbsp;&nbsp;https://www.cnblogs.com/loveyakamoz/archive/2011/07/21/2112804.html&nbsp; 更加详细请观看这篇文档1.1.2&nbsp;添加依赖&nbsp;需要把httpclient的jar包添加到工程中。只需要在工程中添加httpclient的依赖。&nbsp;&nbsp;1.1.3&nbsp;使用方法1.1.3.1&nbsp;使用httpclient执行get请求@Testpublic&nbsp;void&nbsp;doGet()throws&nbsp;Exception {//创建一个httpclient对象CloseableHttpClient httpClient&nbsp;= HttpClients.createDefault();//创建一个GET对象HttpGet get&nbsp;=new&nbsp;HttpGet(“http://www.sogou.com&quot;);//执行请求CloseableHttpResponse response&nbsp;=httpClient.execute(get);//取响应的结果int&nbsp;statusCode&nbsp;=response.getStatusLine().getStatusCode();System.out.println(statusCode);HttpEntity entity&nbsp;=response.getEntity();String string&nbsp;= EntityUtils.toString(entity,“utf-8”);System.out.println(string);//关闭httpclientresponse.close();httpClient.close();}&nbsp;1.1.3.2&nbsp;执行get请求带参数@Testpublic&nbsp;void&nbsp;doGetWithParam()throws&nbsp;Exception{//创建一个httpclient对象CloseableHttpClient httpClient&nbsp;= HttpClients.createDefault();//创建一个uri对象URIBuilder uriBuilder&nbsp;= new&nbsp;URIBuilder(“http://www.sogou.com/web&quot;);uriBuilder.addParameter(“query”,“花千骨”);HttpGet get&nbsp;= new&nbsp;HttpGet(uriBuilder.build());//执行请求CloseableHttpResponse response&nbsp;=httpClient.execute(get);//取响应的结果int&nbsp;statusCode&nbsp;=response.getStatusLine().getStatusCode();System.out.println(statusCode);HttpEntity entity&nbsp;=response.getEntity();String string&nbsp;= EntityUtils.toString(entity,“utf-8”);System.out.println(string);//关闭httpclientresponse.close();httpClient.close();}&nbsp;1.1.3.3&nbsp;使用httpclient执行post请求@Testpublic&nbsp;void&nbsp;doPost()throws&nbsp;Exception {CloseableHttpClient httpClient&nbsp;= HttpClients.createDefault();//创建一个post对象HttpPost post&nbsp;=new&nbsp;HttpPost(“http://localhost:8082/httpclient/post.html&quot;);//执行post请求CloseableHttpResponse response&nbsp;=httpClient.execute(post);String string&nbsp;= EntityUtils.toString(response.getEntity());System.out.println(string);response.close();httpClient.close();}&nbsp;1.1.3.4&nbsp;带参数post请求&nbsp;@Testpublic&nbsp;void&nbsp;doPostWithParam()throws&nbsp;Exception{CloseableHttpClient httpClient&nbsp;= HttpClients.createDefault();//创建一个post对象HttpPost post&nbsp;=new&nbsp;HttpPost(“http://localhost:8082/httpclient/post.html&quot;);//创建一个Entity。模拟一个表单List&lt;NameValuePair&gt;kvList&nbsp;=new&nbsp;ArrayList&lt;&gt;();kvList.add(new&nbsp;BasicNameValuePair(“username”,“zhangsan”));kvList.add(new&nbsp;BasicNameValuePair(“password”,“123”));//包装成一个Entity对象StringEntity entity&nbsp;= new&nbsp;UrlEncodedFormEntity(kvList,“utf-8”);//设置请求的内容post.setEntity(entity);//执行post请求CloseableHttpResponse response&nbsp;=httpClient.execute(post);String string&nbsp;= EntityUtils.toString(response.getEntity());System.out.println(string);response.close();httpClient.close();} HttpClient的使用和封装]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient封装工具类]]></title>
    <url>%2F2018%2F08%2F16%2FHttpClient%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言在日常开发中，我们经常需要通过http协议去调用网络内容，虽然java自身提供了net相关工具包，但是其灵活性和功能总是不如人意，于是有人专门搞出一个httpclient类库，来方便进行Http操作。对于httpcore的源码研究，我们可能并没有达到这种层次，在日常开发中也只是需要的时候，在网上百度一下，然后进行调用就行。在项目中对于这个工具类库也许没有进行很好的封装。在哪里使用就写在哪些，很多地方用到，就在多个地方写。反正是复制粘贴，很方便，但是这样就会导致项目中代码冗余。所以这里简单的对httpcient的简单操作封装成一个工具类，统一放在项目的工具包中，在使用的时候直接从工具包中调用，不需要写冗余代码。httpclient操作实例首先需要在注意的一点是，这是基于httpclient4.5版本的，我们在使用的时候需要引入具体对应jar。下面是具体代码示例import java.io.IOException;import java.security.KeyManagementException;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.util.ArrayList;import java.util.List;import java.util.Map;import javax.net.ssl.SSLContext;import org.apache.commons.lang3.StringUtils;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.ParseException;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClientBuilder;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.ssl.SSLContextBuilder;import org.apache.http.ssl.TrustStrategy;import org.apache.http.util.EntityUtils;/ 基于 httpclient 4.5版本的 http工具类 @author 爱琴孩 */public class HttpClientTool { private static final CloseableHttpClient httpClient; public static final String CHARSET = “UTF-8”; // 采用静态代码块，初始化超时时间配置，再根据配置生成默认httpClient对象 static { RequestConfig config = RequestConfig.custom().setConnectTimeout(60000).setSocketTimeout(15000).build(); httpClient = HttpClientBuilder.create().setDefaultRequestConfig(config).build(); } public static String doGet(String url, Map&lt;String, String&gt; params) { return doGet(url, params, CHARSET); } public static String doGetSSL(String url, Map&lt;String, String&gt; params) { return doGetSSL(url, params, CHARSET); } public static String doPost(String url, Map&lt;String, String&gt; params) throws IOException { return doPost(url, params, CHARSET); } / HTTP Get 获取内容 @param url 请求的url地址 ?之前的地址 @param params 请求的参数 @param charset 编码格式 @return 页面内容 / public static String doGet(String url, Map&lt;String, String&gt; params, String charset) { if (StringUtils.isBlank(url)) { return null; } try { if (params != null &amp;&amp; !params.isEmpty()) { List&lt;NameValuePair&gt; pairs = new ArrayList&lt;NameValuePair&gt;(params.size()); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) { String value = entry.getValue(); if (value != null) { pairs.add(new BasicNameValuePair(entry.getKey(), value)); } } // 将请求参数和url进行拼接 url += “?” + EntityUtils.toString(new UrlEncodedFormEntity(pairs, charset)); } HttpGet httpGet = new HttpGet(url); CloseableHttpResponse response = httpClient.execute(httpGet); int statusCode = response.getStatusLine().getStatusCode(); if (statusCode != 200) { httpGet.abort(); throw new RuntimeException(“HttpClient,error status code :” + statusCode); } HttpEntity entity = response.getEntity(); String result = null; if (entity != null) { result = EntityUtils.toString(entity, “utf-8”); } EntityUtils.consume(entity); response.close(); return result; } catch (Exception e) { e.printStackTrace(); } return null; } / HTTP Post 获取内容 @param url 请求的url地址 ?之前的地址 @param params 请求的参数 @param charset 编码格式 @return 页面内容 @throws IOException */ public static String doPost(String url, Map&lt;String, String&gt; params, String charset) throws IOException { if (StringUtils.isBlank(url)) { return null; } List&lt;NameValuePair&gt; pairs = null; if (params != null &amp;&amp; !params.isEmpty()) { pairs = new ArrayList&lt;NameValuePair&gt;(params.size()); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) { String value = entry.getValue(); if (value != null) { pairs.add(new BasicNameValuePair(entry.getKey(), value)); } } } HttpPost httpPost = new HttpPost(url); if (pairs != null &amp;&amp; pairs.size() &gt; 0) { httpPost.setEntity(new UrlEncodedFormEntity(pairs, CHARSET)); } CloseableHttpResponse response = null; try { response = httpClient.execute(httpPost); int statusCode = response.getStatusLine().getStatusCode(); if (statusCode != 200) { httpPost.abort(); throw new RuntimeException(“HttpClient,error status code :” + statusCode); } HttpEntity entity = response.getEntity(); String result = null; if (entity != null) { result = EntityUtils.toString(entity, “utf-8”); } EntityUtils.consume(entity); return result; } catch (ParseException e) { e.printStackTrace(); } finally { if (response != null) response.close(); } return null; } / HTTPS Get 获取内容 @param url 请求的url地址 ?之前的地址 @param params 请求的参数 @param charset 编码格式 @return 页面内容 / public static String doGetSSL(String url, Map&lt;String, String&gt; params, String charset) { if (StringUtils.isBlank(url)) { return null; } try { if (params != null &amp;&amp; !params.isEmpty()) { List&lt;NameValuePair&gt; pairs = new ArrayList&lt;NameValuePair&gt;(params.size()); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) { String value = entry.getValue(); if (value != null) { pairs.add(new BasicNameValuePair(entry.getKey(), value)); } } url += “?” + EntityUtils.toString(new UrlEncodedFormEntity(pairs, charset)); } HttpGet httpGet = new HttpGet(url); // https 注意这里获取https内容，使用了忽略证书的方式，当然还有其他的方式来获取https内容 CloseableHttpClient httpsClient = HttpClientTool.createSSLClientDefault(); CloseableHttpResponse response = httpsClient.execute(httpGet); int statusCode = response.getStatusLine().getStatusCode(); if (statusCode != 200) { httpGet.abort(); throw new RuntimeException(“HttpClient,error status code :” + statusCode); } HttpEntity entity = response.getEntity(); String result = null; if (entity != null) { result = EntityUtils.toString(entity, “utf-8”); } EntityUtils.consume(entity); response.close(); return result; } catch (Exception e) { e.printStackTrace(); } return null; } /* 这里创建了忽略整数验证的CloseableHttpClient对象 @return / public static CloseableHttpClient createSSLClientDefault() { try { SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() { // 信任所有 public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException { return true; } }).build(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext); return HttpClients.custom().setSSLSocketFactory(sslsf).build(); } catch (KeyManagementException e) { e.printStackTrace(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (KeyStoreException e) { e.printStackTrace(); } return HttpClients.createDefault(); }}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223总结上面就是对于httpclient的简单工具类，对于httpclient，还有很多知识点需要仔细研究，后面再和大家一起来总结学习！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient使用入门]]></title>
    <url>%2F2018%2F08%2F16%2FHttpClient%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HttpClient简介HttpClient 是 Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。官方站点：http://hc.apache.org/最新版本4.5&nbsp;http://hc.apache.org/httpcomponents-client-4.5.x/官方文档：&nbsp;http://hc.apache.org/httpcomponents-client-4.5.x/tutorial/html/index.htmlmaven地址：12345&lt;dependency&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;httpclient&lt;/artifactId&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;4.5.2&lt;/version&gt;&lt;/dependency&gt;HTTP 协议可能是现在 Internet 上使用得最多、最重要的协议了，越来越多的 Java 应用程序需要直接通过 HTTP 协议来访问网络资源。虽然在 JDK 的 java net包中已经提供了访问 HTTP 协议的基本功能，但是对于大部分应用程序来说，JDK 库本身提供的功能还不够丰富和灵活。HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持&nbsp;HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和&nbsp;HTMLUnit&nbsp;都使用了 HttpClient。我们搞爬虫的，主要是用HttpClient模拟浏览器请求第三方站点url，然后响应，获取网页数据，然后用Jsoup来提取我们需要的信息；HttpClient HelloWorld实现首先建一个Maven项目，然后添加httpClient依赖，版本是4.512345&lt;dependency&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;httpclient&lt;/artifactId&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;4.5.2&lt;/version&gt;&lt;/dependency&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546package&nbsp;com.open1111.httpclient;&nbsp;import&nbsp;java.io.IOException;&nbsp;import&nbsp;org.apache.http.HttpEntity;import&nbsp;org.apache.http.ParseException;import&nbsp;org.apache.http.client.ClientProtocolException;import&nbsp;org.apache.http.client.methods.CloseableHttpResponse;import&nbsp;org.apache.http.client.methods.HttpGet;import&nbsp;org.apache.http.impl.client.CloseableHttpClient;import&nbsp;org.apache.http.impl.client.HttpClients;import&nbsp;org.apache.http.util.EntityUtils;&nbsp;public&nbsp;class&nbsp;HelloWorld&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpClient&nbsp;httpClient=HttpClients.createDefault();&nbsp;//&nbsp;创建httpClient实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpGet&nbsp;httpget&nbsp;=&nbsp;new&nbsp;HttpGet(“http://www.open1111.com/&quot;);&nbsp;//&nbsp;创建httpget实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpResponse&nbsp;response=null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;httpClient.execute(httpget);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(ClientProtocolException&nbsp;e)&nbsp;{&nbsp;&nbsp;//&nbsp;http协议异常&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;catch&nbsp;block&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;e)&nbsp;{&nbsp;//&nbsp;io异常&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;catch&nbsp;block&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;//&nbsp;执行get请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpEntity&nbsp;entity=response.getEntity();&nbsp;//&nbsp;获取返回实体&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“网页内容：”+EntityUtils.toString(entity,&nbsp;“utf-8”));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(ParseException&nbsp;e)&nbsp;{&nbsp;&nbsp;//&nbsp;解析异常&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;catch&nbsp;block&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;e)&nbsp;{&nbsp;//&nbsp;io异常&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;catch&nbsp;block&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;//&nbsp;指定编码打印网页内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;e)&nbsp;{&nbsp;&nbsp;//&nbsp;io异常&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;catch&nbsp;block&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;//&nbsp;关闭流和释放系统资源&nbsp;&nbsp;&nbsp;&nbsp;}}运行输出：这里得到了网站首页源码，当然要获得具体数据的话，要用到Jsoup假如你对这些异常都熟悉 我们可以简化下，异常抛出，这样代码可读性好点。12345678910111213141516171819202122import&nbsp;org.apache.http.HttpEntity;import&nbsp;org.apache.http.client.methods.CloseableHttpResponse;import&nbsp;org.apache.http.client.methods.HttpGet;import&nbsp;org.apache.http.impl.client.CloseableHttpClient;import&nbsp;org.apache.http.impl.client.HttpClients;import&nbsp;org.apache.http.util.EntityUtils;&nbsp;public&nbsp;class&nbsp;HelloWorld2&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpClient&nbsp;httpclient&nbsp;=&nbsp;HttpClients.createDefault();&nbsp;//&nbsp;创建httpclient实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpGet&nbsp;httpget&nbsp;=&nbsp;new&nbsp;HttpGet(“http://www.open1111.com/&quot;); &nbsp; &nbsp;//&nbsp;创建httpget实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpResponse&nbsp;response&nbsp;=&nbsp;httpclient.execute(httpget);&nbsp;//&nbsp;执行get请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpEntity&nbsp;entity=response.getEntity();&nbsp;//&nbsp;获取返回实体&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“网页内容：”+EntityUtils.toString(entity,&nbsp;“utf-8”));&nbsp;//&nbsp;指定编码打印网页内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.close();&nbsp;//&nbsp;关闭流和释放系统资源&nbsp;&nbsp;&nbsp;&nbsp;}}但是实际开发的话，我们对于每一种异常的抛出，catch里都需要做一些业务上的操作，所以以后用的话，还是第一种，假如爬虫任务很简单，容易爬取，并且量小，那就第二种。还是要根据具体情况来。HttpClient设置请求头消息User-Agent模拟浏览器HttpClient设置请求头消息User-Agent模拟浏览器比如我们请求&nbsp;www.tuicool.com用前面的代码：123456789101112131415161718192021import&nbsp;org.apache.http.HttpEntity;import&nbsp;org.apache.http.client.methods.CloseableHttpResponse;import&nbsp;org.apache.http.client.methods.HttpGet;import&nbsp;org.apache.http.impl.client.CloseableHttpClient;import&nbsp;org.apache.http.impl.client.HttpClients;import&nbsp;org.apache.http.util.EntityUtils;&nbsp;public&nbsp;class&nbsp;Demo01&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpClient&nbsp;httpClient=HttpClients.createDefault();&nbsp;//&nbsp;创建httpClient实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpGet&nbsp;httpGet=new&nbsp;HttpGet(“http://www.tuicool.com/&quot;); &nbsp; &nbsp; //&nbsp;创建httpget实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpResponse&nbsp;response=httpClient.execute(httpGet);&nbsp;//&nbsp;执行http&nbsp;get请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpEntity&nbsp;entity=response.getEntity();&nbsp;//&nbsp;获取返回实体&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“网页内容：”+EntityUtils.toString(entity,&nbsp;“utf-8”));&nbsp;//&nbsp;获取网页内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.close();&nbsp;//&nbsp;response关闭&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpClient.close();&nbsp;//&nbsp;httpClient关闭&nbsp;&nbsp;&nbsp;&nbsp;}}返回内容：网页内容：&lt;!DOCTYPE html&gt;&lt;html&gt;&nbsp; &nbsp; &lt;head&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;meta http-equiv=”Content-Type” content=”text/html; charset=utf-8”&gt;&nbsp; &nbsp; &lt;/head&gt;&nbsp; &nbsp; &lt;body&gt;&nbsp; &nbsp; &nbsp; &nbsp; &lt;p&gt;系统检测亲不是真人行为，因系统资源限制，我们只能拒绝你的请求。如果你有疑问，可以通过微博 http://weibo.com/tuicool2012/ 联系我们。&lt;/p&gt;&nbsp; &nbsp; &lt;/body&gt;&lt;/html&gt;我们模拟下浏览器 设置下User-Agent头消息：// 设置请求头消息User-AgenthttpGet.setHeader(“User-Agent”, “Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0”);&nbsp;12345678910111213141516171819202122import&nbsp;org.apache.http.HttpEntity;import&nbsp;org.apache.http.client.methods.CloseableHttpResponse;import&nbsp;org.apache.http.client.methods.HttpGet;import&nbsp;org.apache.http.impl.client.CloseableHttpClient;import&nbsp;org.apache.http.impl.client.HttpClients;import&nbsp;org.apache.http.util.EntityUtils;&nbsp;public&nbsp;class&nbsp;Demo01&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpClient&nbsp;httpClient=HttpClients.createDefault();&nbsp;//&nbsp;创建httpClient实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpGet&nbsp;httpGet=new&nbsp;HttpGet(“http://www.tuicool.com/&quot;); &nbsp; &nbsp; //&nbsp;创建httpget实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpGet.setHeader( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//&nbsp;设置请求头消息User-Agent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”User-Agent”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”Mozilla/5.0&nbsp;(Windows&nbsp;NT&nbsp;6.1;&nbsp;Win64;&nbsp;x64;&nbsp;rv:50.0)&nbsp;Gecko/20100101&nbsp;Firefox/50.0”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpResponse&nbsp;response=httpClient.execute(httpGet);&nbsp;//&nbsp;执行http&nbsp;get请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpEntity&nbsp;entity=response.getEntity();&nbsp;//&nbsp;获取返回实体&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“网页内容：”+EntityUtils.toString(entity,&nbsp;“utf-8”));&nbsp;//&nbsp;获取网页内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.close();&nbsp;//&nbsp;response关闭&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpClient.close();&nbsp;//&nbsp;httpClient关闭&nbsp;&nbsp;&nbsp;&nbsp;}}运行 ：当然通过火狐firebug，我们还可以看到其他请求头消息：都是可以通过setHeader方法 设置key value；来得到模拟浏览器请求；HttpClient获取响应内容类型Content-TypeHttpClient获取响应内容类型Content-Type响应的网页内容都有类型也就是Content-Type通过火狐firebug，我们看响应头信息：当然我们可以通过HttpClient接口来获取；HttpEntity的getContentType().getValue() 就能获取到响应类型； &nbsp;1234567891011121314151617181920212223import&nbsp;org.apache.http.HttpEntity;import&nbsp;org.apache.http.client.methods.CloseableHttpResponse;import&nbsp;org.apache.http.client.methods.HttpGet;import&nbsp;org.apache.http.impl.client.CloseableHttpClient;import&nbsp;org.apache.http.impl.client.HttpClients;import&nbsp;org.apache.http.util.EntityUtils;&nbsp;public&nbsp;class&nbsp;Demo2&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpClient&nbsp;httpClient=HttpClients.createDefault();&nbsp;//&nbsp;创建httpClient实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpGet&nbsp;httpGet=new&nbsp;HttpGet(“http://www.java1234.com&quot;); &nbsp; &nbsp; //&nbsp;创建httpget实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpGet.setHeader( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//&nbsp;设置请求头消息User-Agent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”User-Agent”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”Mozilla/5.0&nbsp;(Windows&nbsp;NT&nbsp;6.1;&nbsp;Win64;&nbsp;x64;&nbsp;rv:50.0)&nbsp;Gecko/20100101&nbsp;Firefox/50.0”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpResponse&nbsp;response=httpClient.execute(httpGet);&nbsp;//&nbsp;执行http&nbsp;get请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpEntity&nbsp;entity=response.getEntity(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//&nbsp;获取返回实体&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“Content-Type:”+entity.getContentType().getValue());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//System.out.println(“网页内容：”+EntityUtils.toString(entity,&nbsp;”utf-8”));&nbsp;//&nbsp;获取网页内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.close();&nbsp;//&nbsp;response关闭&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpClient.close();&nbsp;//&nbsp;httpClient关闭&nbsp;&nbsp;&nbsp;&nbsp;}}运行输出：Content-Type:text/html一般网页是text/html当然有些是带编码的，比如请求www.tuicool.com：输出：Content-Type:text/html; charset=utf-8假如请求js文件，比如&nbsp;http://www.open1111.com/static/js/jQuery.js运行输出：Content-Type:application/javascript假如请求的是文件，比如&nbsp;http://central.maven.org/maven2/HTTPClient/HTTPClient/0.3-3/HTTPClient-0.3-3.jar运行输出：Content-Type:application/java-archive当然Content-Type还有一堆，那这东西对于我们爬虫有啥用的，我们再爬取网页的时候 ，可以通过Content-Type来提取我们需要爬取的网页或者是爬取的时候，需要过滤掉的一些网页；HttpClient获取响应状态Status我们HttpClient向服务器请求时，正常情况 执行成功 返回200状态码，不一定每次都会请求成功，比如这个请求地址不存在 返回404服务器内部报错 返回500有些服务器有防采集，假如你频繁的采集数据，则返回403 拒绝你请求。当然 我们是有办法的 后面会讲到用代理IP。这个获取状态码，我们可以用&nbsp;CloseableHttpResponse对象的getStatusLine().getStatusCode()123456789101112131415161718192021222324package&nbsp;com.open1111.httpclient.chap02;&nbsp;import&nbsp;org.apache.http.HttpEntity;import&nbsp;org.apache.http.client.methods.CloseableHttpResponse;import&nbsp;org.apache.http.client.methods.HttpGet;import&nbsp;org.apache.http.impl.client.CloseableHttpClient;import&nbsp;org.apache.http.impl.client.HttpClients;import&nbsp;org.apache.http.util.EntityUtils;&nbsp;public&nbsp;class&nbsp;Demo3&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpClient&nbsp;httpClient=HttpClients.createDefault();&nbsp;//&nbsp;创建httpClient实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpGet&nbsp;httpGet=new&nbsp;HttpGet(“http://www.open1111.com&quot;);&nbsp;//&nbsp;创建httpget实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpGet.setHeader(“User-Agent”,&nbsp;“Mozilla/5.0&nbsp;(Windows&nbsp;NT&nbsp;6.1;&nbsp;Win64;&nbsp;x64;&nbsp;rv:50.0)&nbsp;Gecko/20100101&nbsp;Firefox/50.0”);&nbsp;//&nbsp;设置请求头消息User-Agent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpResponse&nbsp;response=httpClient.execute(httpGet);&nbsp;//&nbsp;执行http&nbsp;get请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“Status:”+response.getStatusLine().getStatusCode());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpEntity&nbsp;entity=response.getEntity();&nbsp;//&nbsp;获取返回实体&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“Content-Type:”+entity.getContentType().getValue());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//System.out.println(“网页内容：”+EntityUtils.toString(entity,&nbsp;”utf-8”));&nbsp;//&nbsp;获取网页内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.close();&nbsp;//&nbsp;response关闭&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpClient.close();&nbsp;//&nbsp;httpClient关闭&nbsp;&nbsp;&nbsp;&nbsp;}}运行输出：Status:200Content-Type:text/html;charset=UTF-8假如换个页面&nbsp;http://www.open1111.com/aaa.jsp因为不存在，所以返回 404HttpClient使用代理IP在爬取网页的时候，有的目标站点有反爬虫机制，对于频繁访问站点以及规则性访问站点的行为，会采集屏蔽IP措施。这时候，代理IP就派上用场了。关于代理IP的话 也分几种&nbsp;透明代理、匿名代理、混淆代理、高匿代理1、透明代理(Transparent Proxy)REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Your IP透明代理虽然可以直接“隐藏”你的IP地址，但是还是可以从HTTP_X_FORWARDED_FOR来查到你是谁。2、匿名代理(Anonymous Proxy)REMOTE_ADDR = proxy IPHTTP_VIA = proxy IPHTTP_X_FORWARDED_FOR = proxy IP匿名代理比透明代理进步了一点：别人只能知道你用了代理，无法知道你是谁。还有一种比纯匿名代理更先进一点的：混淆代理，见下节。3、混淆代理(Distorting Proxies)REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Random IP address如上，与匿名代理相同，如果使用了混淆代理，别人还是能知道你在用代理，但是会得到一个假的IP地址，伪装的更逼真：-）4、高匿代理(Elite proxy或High Anonymity Proxy)REMOTE_ADDR = Proxy IPHTTP_VIA = not determinedHTTP_X_FORWARDED_FOR = not determined可以看出来，高匿代理让别人根本无法发现你是在用代理，所以是最好的选择。一般我们搞爬虫 用的都是 高匿的代理IP；那代理IP 从哪里搞呢 很简单 &nbsp;百度一下，你就知道 一大堆代理IP站点。 &nbsp;一般都会给出一些免费的，但是花点钱搞收费接口更加方便；比如&nbsp;http://www.66ip.cn/httpClient使用代理IP代码：12345678910111213141516171819202122232425262728package&nbsp;com.open1111.httpclient.chap04;&nbsp;&nbsp;import&nbsp;org.apache.http.HttpEntity;import&nbsp;org.apache.http.HttpHost;import&nbsp;org.apache.http.client.config.RequestConfig;import&nbsp;org.apache.http.client.methods.CloseableHttpResponse;import&nbsp;org.apache.http.client.methods.HttpGet;import&nbsp;org.apache.http.impl.client.CloseableHttpClient;import&nbsp;org.apache.http.impl.client.HttpClients;import&nbsp;org.apache.http.util.EntityUtils;&nbsp;public&nbsp;class&nbsp;Demo1&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)throws&nbsp;Exception&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpClient&nbsp;httpClient=HttpClients.createDefault();&nbsp;//&nbsp;创建httpClient实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpGet&nbsp;httpGet=new&nbsp;HttpGet(“https://www.taobao.com/&quot;);&nbsp;//&nbsp;创建httpget实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpHost&nbsp;proxy=new&nbsp;HttpHost(“116.226.217.54”,&nbsp;9999);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RequestConfig&nbsp;requestConfig=RequestConfig.custom().setProxy(proxy).build();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpGet.setConfig(requestConfig);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpGet.setHeader(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”User-Agent”,&nbsp;“Mozilla/5.0&nbsp;(Windows&nbsp;NT&nbsp;6.1;&nbsp;Win64;&nbsp;x64;&nbsp;rv:50.0)&nbsp;Gecko/20100101&nbsp;Firefox/50.0”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpResponse&nbsp;response=httpClient.execute(httpGet);&nbsp;//&nbsp;执行http&nbsp;get请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpEntity&nbsp;entity=response.getEntity();&nbsp;//&nbsp;获取返回实体&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“网页内容：”+EntityUtils.toString(entity,&nbsp;“utf-8”));&nbsp;//&nbsp;获取网页内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.close();&nbsp;//&nbsp;response关闭&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpClient.close();&nbsp;//&nbsp;httpClient关闭&nbsp;&nbsp;&nbsp;&nbsp;}}建议大家用国内代理IP 以及主干道网络大城市的代理IP 访问速度快；HttpClient连接超时及读取超时HttpClient连接超时及读取超时httpClient在执行具体http请求时候 有一个连接的时间和读取内容的时间；HttpClient连接时间所谓连接的时候 是HttpClient发送请求的地方开始到连接上目标url主机地址的时间，理论上是距离越短越快，线路越通畅越快，但是由于路由复杂交错，往往连接上的时间都不固定，运气不好连不上，HttpClient的默认连接时间，据我测试，默认是1分钟，假如超过1分钟 过一会继续尝试连接，这样会有一个问题 假如遇到一个url老是连不上，会影响其他线程的线程进去，所以我们有必要进行特殊设置，比如设置10秒钟 假如10秒钟没有连接上 我们就报错，这样我们就可以进行业务上的处理，比如我们业务上控制 过会再连接试试看。并且这个特殊url写到log4j日志里去。方便管理员查看。HttpClient读取时间所谓读取的时间 是HttpClient已经连接到了目标服务器，然后进行内容数据的获取，一般情况 读取数据都是很快速的，但是假如读取的数据量大，或者是目标服务器本身的问题（比如读取数据库速度慢，并发量大等等..）也会影响读取时间。同上，我们还是需要来特殊设置下，比如设置10秒钟 假如10秒钟还没读取完，就报错，同上，我们可以业务上处理。比如我们这里给个地址&nbsp;http://central.maven.org/maven2/这个是国外地址 连接时间比较长的，而且读取的内容多&nbsp;很容易出现连接超时和读取超时；我们如何用代码实现呢？HttpClient给我们提供了一个RequestConfig类 专门用于配置参数比如连接时间，读取时间以及前面讲解的代理IP等。这里给下示例代码：12345678910111213141516171819202122232425262728import&nbsp;org.apache.http.HttpEntity;import&nbsp;org.apache.http.client.config.RequestConfig;import&nbsp;org.apache.http.client.methods.CloseableHttpResponse;import&nbsp;org.apache.http.client.methods.HttpGet;import&nbsp;org.apache.http.impl.client.CloseableHttpClient;import&nbsp;org.apache.http.impl.client.HttpClients;import&nbsp;org.apache.http.util.EntityUtils;&nbsp;public&nbsp;class&nbsp;Demo2&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)throws&nbsp;Exception&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpClient&nbsp;httpClient=HttpClients.createDefault(); &nbsp; &nbsp; &nbsp;//&nbsp;创建httpClient实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpGet&nbsp;httpGet=new&nbsp;HttpGet(“http://central.maven.org/maven2/&quot;);&nbsp;//&nbsp;创建httpget实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RequestConfig&nbsp;config=RequestConfig.custom()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.setConnectTimeout(5000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.setSocketTimeout(5000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.build();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpGet.setConfig(config);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpGet.setHeader(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”User-Agent”,&nbsp;“Mozilla/5.0&nbsp;(Windows&nbsp;NT&nbsp;6.1;&nbsp;Win64;&nbsp;x64;&nbsp;rv:50.0)&nbsp;Gecko/20100101&nbsp;Firefox/50.0”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CloseableHttpResponse&nbsp;response=httpClient.execute(httpGet);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行http&nbsp;get请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpEntity&nbsp;entity=response.getEntity();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取返回实体&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“网页内容：”+EntityUtils.toString(entity,&nbsp;“utf-8”)); &nbsp;//&nbsp;获取网页内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;response关闭&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpClient.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;httpClient关闭&nbsp;&nbsp;&nbsp;&nbsp;}}]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse安装svn及其使用]]></title>
    <url>%2F2018%2F08%2F11%2Feclipse%E5%AE%89%E8%A3%85svn%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[此教程为eclipse安装svn 安装SVN 安装好后 添加一个资源库输入帐号密码 导出项目 完成至此已经完成 更新和提交]]></content>
      <categories>
        <category>关于技术的深入浅出</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaWeb面试常考题]]></title>
    <url>%2F2018%2F08%2F11%2FjavaWeb%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%2F</url>
    <content type="text"><![CDATA[CoreJavaChapter11ArrayList ，LinkedList的区别LinkedList结构： 都是实现了List接口。前者（数组结构）其实就是一个数组，所以查找快，插入删除效率低。后者（链表结构）查找元素慢，插入删除快。 Vector ，ArrayList的区别相同点：二者都是基于数组不同点：前者线程安全，是重量级，后者线程不安全，属于轻量级 HashSet ，TreeSet的区别：都是set，特点：不能放重复元素，无序的。放入元素的时候，判断元素不重复的方式不一样。Hashset先判断hashcode，如果不等，直接放入集合，如果相等再判断equals。Treeset只根据compareTo方法判断。 HashMap ，HashTable的区别1.HashTable线程安全的，速度慢，HashMap线程不安全，效率高2.HashTable里面key不能为null。HashMap可以为null。HashMap一般情况下key都选用String，key本身是不可变的。 总结：List,Set,Map三个接口区别List有序，可以重复；Set无序，不能重复；Map存的是键值对，key不能重复，可以为空，value可以为空，一般key会用String类型。 经典例题统计下面一篇文章中出现的单词以及每个单词出现的次数。Java is the foundation for virtually every type of networked application and is the global standard for developing and delivering embedded applications。 OracleChar和varchar区别？Char(10)表示固定长度，数据库分配给该列10个字节的长度。Varchar（10）表示最多占用10个字节。取决于数据长度。 (面试题)查询出每个部门中，高处本部门平均工资的员工的雇员号和姓名方案一：12select employee_id,first_name,department_id from employees a where salary&gt;(select avg(salary) from employees where department_id=a.department_id) order by department_id; 方案二：123456--查询所有员工信息(表a)select employee_id,first_name,department_id,salary from employees;--查询部门及其平均工资（表b）select department_id,round(avg(salary)) as pj from employees group by department_id;--关查询select a.employee_id,a.first_name from a inner join b on a.department_id=b.department_id where a.salary&gt;b.pj; 框架Hibernate总结：load，get方式区别1.load是生成一个代理类，也就是采用懒加载机制，get方式直接去获取数据(懒加载就是一开始并不加载持久对象，而是加载代理类，等到要使用该对象的时候才真正加载) 3.get方式在数据库没有对应记录的时候返回null，load方式将会抛出异常。Jvm垃圾回收：无人用的时候，游离态会回收；相互引用的时候也会垃圾回收； SpringAOP,OOP区别？Oop：面向对象 封装，继承，多态 纵向的。Aop：在每个对象某个切入点上，经历共同的切面代码。]]></content>
      <categories>
        <category>关于技术的深入浅出</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle之plSql]]></title>
    <url>%2F2018%2F08%2F03%2FOracle%E4%B9%8BplSql%2F</url>
    <content type="text"><![CDATA[什么是plsql？它是结合Oracle过程语言和结构化查询语言的一种扩展语言，用于在数据库完成一些业务功能。比如完成存储过程和触发器等供程序调用。 基本结构12345678910111213141516DECLARE --标记声明部分 --变量的声明，必须要在begin前面 --声明一些变量、常量、用户定义的数据类型及游标 --注意：赋值用'index:=1'的形式 name varchar(30); --声明时不设置值 name varchar(30):=‘Jack’;--声明带有默认值 name preson.name%type; --直接引用一个表的数据类型BEGIN --标记主程序体部分开始 --主程序体，在这里可以加入各种合法语句EXCEPTION --标记异常处理部分开始 --异常处理程序，当程序中出现错误时执行这一部分END --标记主程序体结束部分 各部分介绍输出语句，用来调试set serveroutput on;--用于开启控制台，运行一次即可s123456declare age int:=0; name varchar(30):='xiaoming';begin dbms_output.put_line('Hello Oracle!!!');end; 输入语句123456789101112accept age prompt '请输入年龄';declare --变量定义，声明,先写变量名，再写变量类型（跟Oracle数据一样） username varchar(30):='zhangsan'; age int;--接受用户输入的变量值begin --赋值 username:='xiaoming'; age:=&amp;age; --逻辑代码 dbms_output.put_line('hello '||username||',your age is:'||age);end; select …into…(变量赋值)用into关键字可以将查询结果的值，设置给变量：12345678--查询员工编号为105的员工姓名和薪水declare name varchar(30):=''; salary number;begin select first_name||' '||last_name ,salary into name,salary from employees where employee_id=105; dbms_output.put_line('姓名是：'||name||',工资：'||salary);end; 注意：select …into..结构必须保证查询只返回一条记录,而且select语句必须和into同时出现，不能单独查询语句。 PL/SQL的主要控制语句if…then elsif … then end if;判断if正确则执行then，否则执行else(elsif为嵌套判断),注意elsif,里面少一下e.12345678910111213--输入一个学生的分数，判断依据：大于等于60分及格，小于60不及格，大于90优秀accept sc prompt '请输入分数'declare score int:=&amp;sc;--赋值begin if score&lt;60 then dbms_output.put_line('你的成绩不及格'); elsif score&lt;90 then dbms_output.put_line('你的成绩及格'); else dbms_output.put_line('你的成绩优秀'); end if;end; Case when … then when … then [else] end,有逻辑的从数值中做出选择123--case when ... then ...注意when后面跟上条件，then结果，最后加上endselect case when name='stu1' then age+1 when name='stu2' then age+2 when name='stu3' then age+3 end cw,name,address from student case var when … then … when … then [else] end1234567891011121314151617181920--经常用于数字表示男女转换select u.id,u.name, (case u.sex when 1 then '男' when 2 then '女' else '空的' end )性别 from users u; ID NAME 性别------- -------------------- ------ 1 张一 空的 2 张二 男 3 张三 空的 4 张四 空的 5 张五 女 6 张六 男 7 张七 女 8 张八 男 Loop exit end loop,循环控制，用判断语句执行exitLoop exit when … end loop,同上，当when为真时执行exitwhile..loop end loop,当while为真时循环123456789101112131415--求1到100的和--首先定义存储和的变量sum，循环变量i--for i in 1..100--求1到100的和declare total int:=0; i int:=1;begin loop total:=total+i; i:=i+1; exit when i&gt;100; end loop; dbms_output.put_line('total:'||total);end; for…in…loop … end loop1234567891011--求1到100的和declare total int:=0; i int:=1;begin for i in 1..100 loop total:=total+i; end loop; dbms_output.put_line('total:'||total);end; 异常情况处理EXCEPTION WHEN &lt;异常情况名&gt; THEN &lt;异常处理代码&gt; WHEN &lt;异常情况名&gt; THEN &lt;异常处理代码&gt; … WHEN OTHERS THEN &lt;异常处理代码&gt;注：sqlcode字段可用于异常中显示异常码,sqlerrm字段用于显具体异常内容123456789101112declare name varchar(33); salary number;begin select first_name||' '||last_name ,salary into name,salary from employees where employee_id=105 ; dbms_output.put_line('姓名是：'||name||',工资：'||salary);exception when no_data_found then dbms_output.put_line('查无此人'); when too_many_rows then dbms_output.put_line('返回多行记录'); dbms_output.put_line(sqlcode||'--'||sqlerrm);--打印错误代码和错误信息，这句话只能在异常捕获部分写改属性 when others then dbms_output.put_line('其他错误');end; Oracle中的存储过程不带输出参数123456789101112131415161718192021--创建存储过程create or replace procedure add_pro(n in int)as total int:=0; i int:=1;begin loop total:=total+i; i:=i+1; exit when i&gt;n; end loop; dbms_output.put_line('total:'||total);end;--调用存储过程declare n int:=10000;begin sum_pro(n);end; 带输出参数12345678910111213141516171819--创建存储过程create or replace procedure getNumberByClassId(cid in int,res out int) as amount int:=0;begin select count(*) into amount from student where cla_id=cid;--查询学生数量，并且赋值给amount res:=amount; amount:=1/0; exception when others then dbms_output.put_line('程序有异常'||',异常的代码是：'||sqlcode||',错误信息是：'||sqlerrm);end;----调用存储过程declare amount int:=0;begin getnumberbyclassid(221,amount); dbms_output.put_line('数量：'||amount);end; 注意：1.创建存储过程如果带有参数，输入和输出参数分别用in和out标识，放在参数名的后面。也可以用in out标识，表示既可以输入实参又可以作为输出。2.存储过程调用的时候可以用plsql块来测试。直接写存储过程的名称。 游标的使用游标是什么？内存里面一块存储区，里面存放查询出来的结果集，游标可以在这些行之间游动。当我们修改某一行记录的时候，首先要定位到该行记录。 隐式游标(了解)SQL%ROWCOUNT整型 代表DML语句成功执行的数据行数。SQL%NOTFOUND布尔型 与SQL%FOUND属性返回值相反。SQL%ISOPEN布尔型 DML执行过程中为真，结束后为假123456789101112131415--进行批量更新时候判断成功多少行--plsql支持boolean，但是Oracle没有布尔型，mysql有declare rc int; issuc BOOLEAN;begin update student set stu_age=22; --这一次更新语句一共更新了多少行 rc:=SQL%rowcount; dbms_output.put_line('这次更新影响的行数是：'||rc); issuc:=SQL%found; if issuc then dbms_output.put_line('这次更新成功：'); end if;end; 显式游标(静态游标)静态游标指的是程序执行的时候不需要再去解析sql语言，对于sql语句的解析在编译的时候就可以完成的。动态游标由于含有参数，对于sql语句的解析必须要等到参数确定的时候才能完成。从这个角度来说，静态游标的效率也比动态游标更高一些。12345678910111213141516171819202122--依次在控制台输出所有学生的信息declare--获取游标cc--注意select后必须为*否则报错 cursor cc is select * from student;--定义行记录的类型 recordc student%rowType;begin--打开游标 open cc;--使用游标 loop--从游标一行一行取记录 fetch cc into recordc; dbms_output.PUT_LINE('姓名是：'||recordc.name||' 年龄是：'||recordc.age); exit when cc%notfound; end loop; --显示游标必须手动关闭 if cc%isopen then close cc; end if;end; 动态游标动态游标的sql语句在运行的时候才确定的，这种游标叫做动态游标1234567891011121314151617--循环遍历所有的学生declare type mycursor is ref cursor;--定义一个类型，类型表示一个动态游标 c mycursor;--定义一个mycursor类型的游标，变量名是c record student%rowtype;begin open c for 'select * from student';--给动态游标变量c赋值 loop fetch c into record; dbms_output.put_line('学生姓名：'||record.stu_name); exit when c%notfound; end loop; if c%isopen then close c; end if;--end; 123456789101112131415161718192021--写一个存储过程，输入参数是表名，打印出该表的所有idcreate or replace procedure printTableId(tableName in varchar)as tid int;--存储表的id列的值 type mycursor is ref cursor; c mycursor;begin open c for 'select id from '||tableName; loop fetch c into tid; exit when c%notfound; dbms_output.put_line('当前id值：'||tid); end loop; if c%isopen then close c; end if;end;--调用存储过程，如果不定义变量，declare可以省略begin printtableid('class');end;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle常用函数]]></title>
    <url>%2F2018%2F08%2F02%2FOracle%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Oracle常用函数关于伪表伪表，对每一个数据库用户而言都存在一个表名叫做dual的表。用作日常查询，用来计算，显示日期，转换日期，所有这些操作都不涉及到我们自己定义的表。1234--请计算9999*88+888=？select 9999*88+888 from dual;--显示当前日期SELECT SYSDATE FROM dual; 字符串类单行函数：1.upper范例：观察转大写的函数1SELECT UPPER('hello') FROM dual; 2.lower范例：观察转小写的操作，将所有的雇员姓名按照小写字母返回1SELECT LOWER(ename) FROM emp; 3.length范例：查询出每个雇员姓名的长度1SELECT ename,LENGTH(ename) FROM emp; 4.replace范例：使用字母“_”替换掉姓名中的所有字母“A”1SELECT REPLACE(ename,'A','_') FROM emp; 5.substr字符串截取操作有两种语法1234--从开始第三个字符截取到结尾SELECT ename,SUBSTR(ename,3) FROM emp;--从开始第三个字符截取到第五个SELECT ename,SUBSTR(ename,3,5) FROM emp; 数字类单行函数：1.验证round()函数round(n,[m]) 该函数用于执行四舍五入，如果省掉m，则四舍五入到整数。如果m是正数，则四舍五入到小数点的m位后。如果m是负数，则四舍五入到小数点的m位前。12SELECT round(23.75123) FROM dual; --返回24SELECT round(23.75123, 1) FROM dual; --返回23.8 日期类函数如果现在要想进行日期的操作，则首先有一个必须要解决的问题，就是如何取得当前的日期，这个当前日期可以使用“SYSDATE”取得，代码如下：SELECT SYSDATE FROM dual;除了以上的当前日期之外，在日期中也可以进行若干计算：12345--日期 + 数字 = 日期，表示若干天之后的日期；SELECT SYSDATE + 3,SYSDATE + 300 FROM dual;--日期 – 数字 = 日期，表示若干天前的日期；SELECT SYSDATE - 3,SYSDATE - 300 FROM dual;--日期 – 日期 日期和字符串转换函数to_char函数:将日期转换成字符串1234--把员工的入职时间转成字符串，yyyy-MM-ddselect to_char(hire_date,'yyyy-MM-dd') from employees where 1=1 ;--把当前日期转成字符串，yyyy-MM-ddselect to_char(sysdate,'yyyy-MM-dd') from dual ; to_date函数:将字符串转换成日期12--给定一个字符串'2017-09-09' 转成日期select to_date('2017-09-09','yyyy-MM-dd') from dual; 可能写到insert into () values(日期) 其他函数decode函数12--显示员工工资临界档次，等于3000显示低收入，等于5000显示中等，等于8000显示高薪。select decode(salary,3000,'低收入',5000,'中等',8000,'高薪','其他') from employees ;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js的包管理]]></title>
    <url>%2F2018%2F07%2F07%2FNode.js%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[npm官网: http://www.npmjs.com 常用命令1234567npm install name 安装npm uninstall name 卸载npm version 查看版本npm help 查看帮助 npm上传自己的模块(开源社区) 注册、登录一个用户 12npm adduser 添加用户npm login 登录用户 检查是否登录成功 1whoami 查看当前用户 建立package 1npm init 初始化 发布 1npm publish 发布 注意:在发布一次必须更高的版本号 删除发布1npm unpublish name -force 删除发布 package.json及相关字段package.json是项目的全局描述文件(在运行npm init时生成)，简单结构如下:1234567891011121314&#123; "name": "npm", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "node index.js" &#125;, "author": "", "license": "ISC", "dependencies": &#123; "grunt": "^1.0.3" &#125;&#125; scripts此字段用于脚本命令的书写，注意只有npm help中存在的命令才能引用脚本相关常用脚本:1234npm start 启动 npm stop 关闭npm restart 重启npm test 测试 files此字段包含了工程所包含的文件 版本号声明(dependencies)格式：主版本.次版本.bulid号1234567～version 近似版本（次要版本）^version 兼容版本* 任何版本 a～b ａ～之间 通过package.json快速创建工程1.在A处工程目录下运行命令npm install name --save将需要的依赖添加到package.json 2.将package.json拷贝到B处工程目录下，在B工程目录下运行npm install命令，将自动下载所有依赖包 安装cnpmcnpm镜像官网: http://npm.taobao.org此处安装阿里的npm国内镜像cnpm(因为npm慢)，安装后命令使用方法同npm，仅将npm换成cnpm即可安装命令(官网上有):1npm install -g cnpm --registry=https://registry.npm.taobao.org browserifyBrowserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码，通过预编译让前端 Javascript 可以直接使用 Node NPM 安装的一些库。 1.安装1cnpm -g install browserify 2.编译1browserify 要编译的js文件 &gt; 结果文件.js 3.例A.js:123module.exports=&#123; a: 12&#125; B.js:123module.exports=&#123; b: 52&#125; C.js:123var mud1 = require('./1.js')//非系统模块，./不能省var mud2 = require('./2.js')alert(mud1.a+mud2.b) 最终使用browserify C.js &gt; index.js命令编译：编译后C.js需要的所有其它文件都会被编译进index.js 中，包括很多层 require() 的情况也会一起被递归式的编译过来。编译好的 js可以直接拿到浏览器使用1&lt;script src="bundle.js"&gt;&lt;/script&gt; browser-sync直接上官网: http://www.browsersync.cn/#install]]></content>
      <categories>
        <category>关于技术的深入浅出</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java将word转换成pdf]]></title>
    <url>%2F2018%2F06%2F18%2FJava%E5%B0%86word%E8%BD%AC%E6%8D%A2%E6%88%90pdf%2F</url>
    <content type="text"><![CDATA[使用jacob将 word转换为pdf 下载SaveAsPDFandXPS并安装 下载jacob.jar将jacob-1.19-x64.dll放在 C:\jdk1.8.0\jre\bin 目录下将jacob.jar导入项目的lib目录下即可 具体实现代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.jd.poi.test;import java.io.File;import com.jacob.activeX.ActiveXComponent;import com.jacob.com.ComThread;import com.jacob.com.Dispatch;import com.jacob.com.Variant;/** * 效果最好的一种方法，但是需要 window 环境，而且速度是最慢的需要安装 msofficeWord 以及 SaveAsPDFandXPS.exe ( * word 的一个插件，用来把 word 转化为 pdf，可以不用安装，本次未安装测试通过 ) * * SaveAsPDFandXPS * 下载地址：http://www.microsoft.com/zh-cn/download/details.aspx?id=7 * jacob 包下载地址：http://sourceforge.net/projects/jacob-project/ * * jacob.jar 放在 E:\jdk1.5.0_14\jre\lib\ext * jacob.dll 放在 E:\jdk1.5.0_14\jre\bin * * @author u Y * */public class WordToPdf &#123; private static final int wdFormatPDF = 17; // PDF 格式 public void wordToPDF(String sfileName, String toFileName) &#123; System.out.println("启动 Word..."); long start = System.currentTimeMillis(); ActiveXComponent app = null; Dispatch doc = null; try &#123; app = new ActiveXComponent("Word.Application"); app.setProperty("Visible", new Variant(false)); Dispatch docs = app.getProperty("Documents").toDispatch(); doc = Dispatch.call(docs, "Open", sfileName).toDispatch(); System.out.println("打开文档..." + sfileName); System.out.println("转换文档到 PDF..." + toFileName); File tofile = new File(toFileName); if (tofile.exists()) &#123; tofile.delete(); &#125; Dispatch.call(doc, "SaveAs", toFileName, // FileName wdFormatPDF); long end = System.currentTimeMillis(); System.out.println("转换完成..用时：" + (end - start) + "ms."); &#125; catch (Exception e) &#123; System.out.println("========Error:文档转换失败：" + e.getMessage()); &#125; finally &#123; Dispatch.call(doc, "Close", false); System.out.println("关闭文档"); if (app != null) app.invoke("Quit", new Variant[] &#123;&#125;); &#125; // 如果没有这句话,winword.exe进程将不会关闭 ComThread.Release(); &#125; public static void main(String[] args) &#123; WordToPdf d = new WordToPdf(); d.wordToPDF("E:\\aaa\\Spring.doc", "E:\\aaa\\Spring.pdf"); &#125;&#125; 将word转换为html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux小记]]></title>
    <url>%2F2018%2F06%2F04%2Flinux%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用ab对web服务进行压力测试常用的压力测试工具:Apache Benchmark(ab)LoadRunner 查看ab命令的软件依赖包是否安装,ab命令默认位置为/usr/bin/ab 1# rpm -qa | grep httpd-tools 没有则安装相关软件包，有则忽略此步骤 1# yum install -y httpd-tools 使用ab命令进行压力测试 1# ab -c 1 -n 10000 http://..... -c——模拟多个客户端同时进行访问 -n——本次压力测试要完成的请求个数 使用Nginx高性能Web服务器安装 下载nginx归档压缩文件包:nginx 安装开发套件: 1# yum groupinstall -y "Development Tools" 解压缩归档压缩文件 1# tar -xzvf nginx-1.14.0.tar.gz 检查编译环境、相关的库文件以及配置参数并生成makefile 12# cd nginx-1.14.0# ./configure 如果有依赖的库文件没安装则进行此步骤，安装依赖的库文件,安装完成后继续运行./configure命令直到生成makefile文件: 12# yum install -y pcre-devel# yum install -y zlib-devel 对源代码进行编译，生成可执行文件 1# make 将生成的可执行文件安装到计算机中,默认安装目录为/usr/local/nginx 1# make install 启动服务器启动nginx服务,默认使用80端口号12# cd /usr/local/nginx/sbin# ./nginx 使用netstat -tupln | grep 80命令查看80端口的使用情况nginx默认主页面配置信息123456789101112server &#123; listen 80;//端口 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html;//主页位置，可以放一个绝对路径文件 index index.html index.htm; &#125; 关闭nginx服务器 通过ps aux | grep nginx命令查看nginx的进程id 关闭1# kill -s QUIT 14011(进程id) 创建定时任务linux下常用用于创建定时任务的服务(linux中的服务常以d结尾):atd服务crond服务(常用) 查看相关文件使用cat /etc/crontab命令可查看创建定时任务的语法,相应字段对应着相应的含义使用ls -ld /etc/cron*命令可查看任务相关的文件及文件夹,将脚本放到相应的文件中则会相应的周期性运行脚本 创建定时任务创建一个每分钟输出一次hello linux的定时任务(默认进入vi编辑器，保存并退出即可创建定时任务): 1# crontab -e 12345* * * * * root echo "hello linux"~~~:x 相关字段用含义如下: 1234567.---------------- minute (0 - 59)| .------------- hour (0 - 23)| | .---------- day of month (1 - 31)| | | .------- month (1 - 12) OR jan,feb,mar,apr ...| | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat| | | | |* * * * * user-name command to be executed 查看当前用户的定时任务列表 1# crontab -l 使用iotop实时监控系统磁盘IO此命令类似于window中的任务管理器 查看相关的软件包 1# yum list iotop 安装相关的命令 1# yum install -y iotop 查看相关的IO状况(命令类似于系统自带的top命令) 1# iotop Linux下挂载FAT文件系统 到网址repoforge.org/use/下载下图文件:相关文件下载网址：rpmforge-release-0.5.3-1.el6.rf.i686.rpm 到rpm文件包所在的目录运行rpm -ivh rpmfilename命令安装相关的库文件 使用yum list | grep ntfs命令查看库中包含的rpm安装包文件使用yum install fuse-ntfs-3g命令安装相关驱动模块,至此已经可以自动挂载FAT格式磁盘 运行mount命令查看所有已挂载的文件系统 挂载FAT文件系统的磁盘:1# moun.ntfs 挂载点 需挂载磁盘 使用压缩PNG图片工具 到相应的网址repoforge.org/use/下载yum源的rpm包使用命令rpm -ivh rpmfilename进行安装：相关文件下载网址：rpmforge-release-0.5.3-1.el6.rf.i686.rpm 使用yum install -y optipng命令进行软件安装 安装完成后使用optipng filename命令即可进行png格式图片压缩 监控系统当前监听使用的端口 第一种方式查看当前的网络状态1# netstat -tupln -tupln——列出当前系统上所有正在监听的端口 第二种方式列出所有正在监听的端口1# lsof -i]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中yum方式安装mysql]]></title>
    <url>%2F2018%2F05%2F30%2Flinux%E4%B8%ADyum%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[1.下载mysql的repo源1$ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 2.安装mysql-community-release-el7-5.noarch.rpm包1$ sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm 安装这个包后，会获得两个mysql的yum repo源：/etc/yum.repos.d/mysql-community.repo/etc/yum.repos.d/mysql-community-source.repo3.安装mysql1$ sudo yum install mysql-server 根据提示安装就可以登录了,不过安装完成后没有密码,需要重置密码4.重置mysql密码1$ mysql -u root 登录时有可能报这样的错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：1$ sudo chown -R root:root /var/lib/mysql 重启mysql服务:1$ service mysqld restart 接下来登录重置密码：12345$ mysql -u rootmysql &gt; use mysql;mysql &gt; update user set password=password('123456') where user='root';mysql &gt; flush privileges;//强制权限设置mysql &gt; exit;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中mysql登录失败]]></title>
    <url>%2F2018%2F05%2F27%2Flinux%E4%B8%ADmysql%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[提示：ERROR 1044 (42000): Access denied for user ‘‘@’localhost’ to database ‘mysql’。前两天也出现过这个问题，网上找了一个比较流行的方法（见方法一），搞定了。今天又用这个试了试，却搞不定，在网上找了半天，终于发现是因为mysql数据库的user表里，存在用户名为空的账户即匿名账户，导致登录的时候是虽然用的是root，但实际是匿名登录的，通过错误提示里的‘‘@’localhost’可以看出来，于是解决办法见方法二。 方法一： 关闭mysql 1# service mysqld stop 屏蔽权限 123# mysqld_safe --skip-grant-table 屏幕出现： Starting demo from ..... 新开起一个终端输入 1234# mysql -u root mysql mysql&gt; UPDATE user SET Password=PASSWORD('newpassword') where USER='root'; mysql&gt; FLUSH PRIVILEGES;//记得要这句话，否则如果关闭先前的终端，又会出现原来的错误 mysql&gt; exit 方法二： 关闭mysql 1# service mysqld stop 屏蔽权限 123# mysqld_safe --skip-grant-table 屏幕出现： Starting demo from ..... 新开起一个终端输入 1234# mysql -u root mysql mysql&gt; delete from user where USER=''; mysql&gt; FLUSH PRIVILEGES;//记得要这句话，否则如果关闭先前的终端，又会出现原来的错误 mysql&gt; exit]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题目录结构]]></title>
    <url>%2F2018%2F05%2F23%2FNext%E4%B8%BB%E9%A2%98%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[主题目录结构图:代码高亮兼容图:12]]></content>
      <categories>
        <category>主题相关</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js入门详解]]></title>
    <url>%2F2018%2F05%2F23%2FVue.js%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[❉注意(非常重要)❉： 不要将Vue挂载到&lt;html&gt;或&lt;body&gt;,挂载到此两个元素上，数据绑定失败！！！ 指令中获取数据不需要加双大括号 正常html位置中获取数据需要加双大括号 当页面Vue.js语法使用错误或数据名称书写错误时,页面一般显示为空白 注意Vue实例写在文档加载函数中，否则可能绑定数据等不成功 语法错误和指令名书写错将导致数据绑定失败(v-model 缺少逗号等) 关键字和数据名称书写错将导致页面空白(el data methods Vue new true false等) Vue.js是什么Vue(读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。 安装创建一个.html文件，然后通过如下方式引入Vue：12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; 或者：12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 或者直接下载vue.js文件拷贝到本地引用即可 基本实例模型Vue.js的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统。每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：1234&lt;!-- html代码: --&gt;&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456789101112131415//js代码var app = new Vue(&#123; el: '#app',//选择器 data: &#123;//数据(model) message: 'Hello Vue!' &#125;, methods: &#123; //方法 ... &#125;, created: function () &#123;//生命周期钩子 // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;) 生命周期钩子每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 # beforeCreate——在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 # created——在实例创建完成后被立即调用。 # beforeMount——在挂载开始之前被调用：相关的 render 函数首次被调用 # mounted——el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 # beforeUpdate——数据更新时调用，发生在虚拟 DOM 打补丁之前 # updated——由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 # activated——keep-alive 组件激活时调用 # deactivated——keep-alive 组件停用时调用 # beforeDestroy——实例销毁之前调用。在这一步，实例仍然完全可用。 # destroyed——Vue 实例销毁后调用12345678910//列：new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;) 模板语法插值数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： #文本标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。1234&lt;!-- html代码： --&gt;&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567//js代码var app = new Vue(&#123; el: '#app', data: &#123; msg: 'hello vue' &#125;&#125;) #不更新的文本(一次性)通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：1234&lt;!-- html代码： --&gt;&lt;div id="app"&gt; &lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt; 1234567//js代码var app = new Vue(&#123; el: '#app', data: &#123; msg: 'hello vue' &#125;&#125;) #原始html双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：12345&lt;!-- html代码： --&gt;&lt;div id="app"&gt; &lt;!-- 此处将显示为：此处为html文字 --&gt; &lt;div v-html="Html"&gt;&lt;/div&gt;&lt;/div&gt; 1234567//js代码var app = new Vue(&#123; el: '#app', data: &#123; Html: '&lt;span&gt;此处为html文字&lt;/span&gt;' &#125;&#125;) 指令指令 (Directives) 是带有 v- 前缀的特殊特性。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM注意：指令插值不需要双大括号1234&lt;!-- html代码： --&gt;&lt;div id="app"&gt; &lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt; 1234567//js代码var app = new Vue(&#123; el: '#app', data: &#123; seen: true &#125;&#125;) 条件与循环条件(v-if/v-show)v-if指令根据条件控制是否渲染(显示)元素：1234&lt;!-- html代码： --&gt;&lt;div id="app"&gt; &lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt; 1234567//js代码var app = new Vue(&#123; el: '#app', data: &#123; seen: true &#125;&#125;) v-show指令根据条件控制是或否展示元素:1234&lt;!-- html代码： --&gt;&lt;div id="app"&gt; &lt;p v-show="seen"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt; 1234567//js代码var app = new Vue(&#123; el: '#app', data: &#123; seen: true &#125;&#125;) v-if是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建v-show就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 循环(v-for)v-for指令可以绑定数组的数据来渲染一个项目列表：12345678&lt;!-- html代码：--&gt;&lt;div id="app"&gt; &lt;ol&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 1234567891011//js代码var app = new Vue(&#123; el: '#app', data: &#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue' &#125;, &#123; text: '整个牛项目' &#125; ] &#125;&#125;) 事件监听注册监听为了让用户和你的应用进行交互，我们可以用v-on指令添加一个事件监听器，通过它调用在Vue实例中定义的方法：12345&lt;!-- html代码：--&gt;&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click="reverseMessage"&gt;逆转消息&lt;/button&gt;&lt;/div&gt; 123456789101112//js代码var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js!' &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;&#125;) 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：1234&lt;!-- html代码：--&gt;&lt;button v-on:click="warn($event)"&gt; Submit&lt;/button&gt; v-on:click可以简写为@click 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求,因此Vue.js 为 v-on 提供了事件修饰符修饰符是由点开头的指令后缀来表示的,使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。·.stop·.prevent·.capture·.self·.once·.passive12345678910111213141516171819&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt; 按键修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：123456789&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13="submit"&gt;&lt;!--记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名--&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; 所有的按键别名:·.enter·.tab·.delete (捕获“删除”和“退格”键)·.esc·.space·.up·.down·.left·.right 属性绑定一些指令能够接收一个“参数”，在指令名称之后以冒号表示。v-bind:参数动态地绑定一个或多个特性，或一个组件 prop 到表达式。1234&lt;!-- html代码 --&gt;&lt;div id="app"&gt; &lt;a v-bind:href="url"&gt;...&lt;/a&gt;&lt;/div&gt; 1234567//js代码var app = new Vue(&#123; el: '#app', data: &#123; url: 'www.baidu.com' &#125;&#125;) 在这里 href 是参数，告知 v-bind 指令将该元素的 href 特性与表达式 url 的值绑定。 v-bind:herf可以简写为:herf 数据双向绑定Vue提供了v-model指令，它能轻松实现表单输入和应用状态之间的双向绑定。12345&lt;!-- html代码：--&gt;&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt; 1234567//js代码var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;) 网络请求(ajax)要进行网络请求需要引用vue-resource.js：12&lt;!-- vue-resource.js --&gt;&lt;script type="text/javascript" src="https://cdn.bootcss.com/vue-resource/1.5.0/vue-resource.js"&gt;&lt;/script&gt; get方式1234&lt;!-- html代码：--&gt;&lt;div id="app"&gt; &lt;button @click="get"&gt;get interaction&lt;/button&gt;&lt;br /&gt;&lt;/div&gt; 1234567891011121314151617181920//js代码var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;, methods: &#123; get: function()&#123; this.$http.get('get.php',//第一个参数为要请求的地址 &#123;//第二个参数为给后台传的值 a: 1, b: 2 &#125;).then(function(res)&#123;//请求成功函数 alert(res.data);//res.data为获取的json数据 &#125;,function()&#123;//请求失败函数 &#125;); &#125; &#125;&#125;) post方式1234&lt;!-- html代码：--&gt;&lt;div id="app"&gt; &lt;button @click="post"&gt;post interaction&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819202122//js代码var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;, methods: &#123; post: function()&#123; this.$http.post('post.php', &#123;//参数 a: 1, b: 2 &#125;,&#123; emulateJSON: true//第三个参数为option配置,post请求时加此配置 &#125;).then(function(res)&#123;//请求成功函数 alert(res.data);//res.data为获取的json数据 &#125;,function()&#123;//请求失败函数 &#125;); &#125; &#125;&#125;) jsonp跨域请求1234&lt;!-- html代码：--&gt;&lt;div id="app"&gt; &lt;button @click="post"&gt;post interaction&lt;/button&gt;&lt;/div&gt; 123456789101112131415161718192021//js代码var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;, methods: &#123; jsonp: function()&#123; this.$http.jsonp('https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',//此例为跨域请求百度 &#123;//参数 wd: 'a', &#125;,&#123;//第三个参数为option配置 jsonp: 'cb'//callback名称,不同的域名称不同 &#125;).then(function(res)&#123;//请求成功函数 alert(res.data.s);//跨域的jsonp数据 &#125;,function()&#123;//请求失败函数 &#125;); &#125; &#125;&#125;) 组件化应用构建]]></content>
      <categories>
        <category>关于技术的深入浅出</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入门详解]]></title>
    <url>%2F2018%2F05%2F20%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注册 打开微信公众平台点击小程序注册查看详情 在小程序注册页面点击注册开始注册 注册 注册完成后返回微信公众平台登录即可 登录小程序复制AppID以备开发者工具的使用 开发者工具 下载开发者工具:开发者工具 打开开发者工具将上一步复制的AppID填入开始项目开发 小程序结构整体结构图JS 交互逻辑 在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。 可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力 JSON配置app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等123456789101112&#123; "pages":[ "pages/index/index", "pages/logs/logs" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle":"black" &#125;&#125; pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。 通过在app.json的pages字段中添加类似于pages/new/new字段即可添加新页面 第一个字段为自动加载的主页面字段 window字段 —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。 WXML模板WXML 充当的就是类似 HTML 的角色，用于显示界面内容。 通过’双花括号’的语法把一个变量绑定到界面上，我们称为数据绑定。 仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达 WXSS样式WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改 模块化模块化即小程序中js的引用 导出模块 12345678910//.js代码//模块导出形式:modeule.exports.x=x或exports.x=x或module.exports=&#123;&#125;function hello(user)&#123; return '欢迎回来：+$&#123;user&#125;';&#125;function back(user) &#123; return '欢迎下次再来：$&#123;user&#125;';&#125;module.exports.hello=hello;exports.back=back; 引用模块 123456789//.js代码//模块引用形式:require(模块路径)const app = getApp();var com = require('../../utils/common.js');Page(&#123; ...&#125;) 常用apiApp()注册一个小程序(全局app.js中)1234//app.jsApp(&#123; ...&#125;) Page()注册一个页面(单页.js中)123Page(&#123; ...&#125;) getApp()页面中获取全局的app1234567const app = getApp();Page(&#123; test: function()&#123; //获取app全局文件中的数据 app.obj &#125;&#125;) this.data.msg获取当前实时数据1234567891011Page(&#123; data: &#123; msg: 'Hello World' &#125; , test: function()&#123; //获取当前data中的msg console.log(this.data.msg) &#125;&#125;) this.setData({})更改数据同步view123456789101112Page(&#123; data: &#123; msg: 'Hello World' &#125;, test: function()&#123; //设置当前data中的msg为hello this.setData(&#123; msg: 'hello' &#125;) &#125;&#125;) 事件绑定12345678910111213&lt;!-- .wxml代码:用bindtap绑定单击事件 --&gt;&lt;button size="mini" type='primary' bindtap='nav'&gt;注册单机事件&lt;/button&gt;//.js代码:Page(&#123; nav: function()&#123; ... &#125;&#125;) 页面跳转的两种方式 标签方式 12&lt;!-- .wxml代码: --&gt;&lt;navigator url='../news/news'&gt;第一种跳转方式&lt;/navigator&gt; js单击事件跳转方式 1234567891011121314151617&lt;!-- .wxml代码: --&gt;&lt;button size="mini" type='primary' bindtap='nav'&gt;第二种跳转方式&lt;/button&gt;//.js代码:Page(&#123; nav: function()&#123; wx.navigateTo(&#123; url: '/pages/news/news' &#125;) &#125;&#125;) wx:if条件渲染 在框架中，使用 wx:if来判断是否需要渲染(显示)该代码块： 12&lt;!-- .wxml代码 --&gt;&lt;view wx:if="&#123;&#123;condition&#125;&#125;"&gt; True &lt;/view&gt; 也可以用wx:elif和wx:else来添加一个 else 块： 1234&lt;!-- .wxml代码 --&gt;&lt;view wx:if="&#123;&#123;length &gt; 5&#125;&#125;"&gt; 1 &lt;/view&gt;&lt;view wx:elif="&#123;&#123;length &gt; 2&#125;&#125;"&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt; 如果要一次性判断多个组件标签，可以使用一个 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。 12345&lt;!-- .wxml代码 --&gt;&lt;block wx:if="&#123;&#123;true&#125;&#125;"&gt; &lt;view&gt; view1 &lt;/view&gt; &lt;view&gt; view2 &lt;/view&gt;&lt;/block&gt; wx:for列表渲染在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件12345678910111213141516&lt;!-- .wxml代码 --&gt;&lt;view wx:for="&#123;&#123;array&#125;&#125;"&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt;//.js代码//默认数组的当前项的下标变量名默认为 index//数组当前项的变量名默认为 itemPage(&#123; data: &#123; array: [&#123; message: 'foo', &#125;, &#123; message: 'bar' &#125;] &#125;&#125;)]]></content>
      <categories>
        <category>关于技术的深入浅出</category>
      </categories>
      <tags>
        <tag>WeiXin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门详解]]></title>
    <url>%2F2018%2F05%2F12%2FGit%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Git结构和状态Git的3层结构 working directory——————工作区 staging index——————暂存区 git directory(Repository)——————版本库 Git中文件的四种状态 untracked——————未被追踪 Modified——————表示工作区修改了某个文件但是还有没有添加到暂存区 Start——————表示把工作区修改的文件添加到了暂存区但是没有提交到版本库 Committed——————表示数据被安全地存储到本地仓库中 Git基本命令 git init——————初始化git仓库，出现.git文件(将文件夹初始化成git仓库) git add——————将文件从工作区添加到暂存区(对文件进行追踪) 123git add filename 将文件添加到暂存区git add . 将工作目录下所有修改的文件添加到暂存区 git commit——————将暂存区的文件添加到版本库 123git commit -m 'description' 将暂存区的文件提交到版本库git commit -am 'description' 跳过`git add`添加到暂存区的命令，直接将工作区所有以跟踪的文件提交 git log——————查看提交的日志信息 git status——————查看项目文件的状态 git config——————对git进行配置 12345git config --global user.name xzbk 配置用户名git config --global user.email 1063175795@qq.com 配置用户邮箱git config --list 查看git配置信息 Git撤销操作 git commit --amend——————撤销上一次提交，并将暂存区的文件重新提交 git checkout -- filename——————拉取暂存区的文件并将其替换工作区的文件(如果暂存区没有则去版本库中获) git reset HEAD filename——————拉取最近一次提交的版本库中的这个文件到暂存区，该操作不影响工作区 git reset --option(版本号)12345git reset --head 版本号 将暂存区工作区强行回退到相应版本git reset --mixed 版本号 将版本库和暂存区回退到相应版本，工作区不受影响git reset --soft 版本号 将版本库回退到相应版本 Git文件删除 git rm filename——————删除工作区及暂存区中的该文件，相当于删除文件后执行git add 12345git rm --cached filename 在不小心将不需要追踪的文件添加到暂存区，想删除暂存区的文件但不是删除工作区的文件很有用git rm -f filename 当工作区或者暂存区文件修改了glob模式 git mv filename 12345mv oldname newnamegit rm oldnamegit add newname Git分支git分支的创建、修改、切换、删除 git branch——————查看分支口 git branch branchname——————创建分支 git branch -m oldname newname——————修改分支名称 git checkout [-b] branchname——————切换分支[创建并切换分支] git branch -d branchname——————删除分支 分支的合并 HEAD——————分支的指针，指针HEAD指向当前工作分支，在切换分支时执行新的分支 git diff——————比较差异 1234567git diff 比较工作区与暂存区文件的差异git diff --staged 比较暂存区与版本库文件的差异git diff version1 version2 比较分支内两个版本号的差异git diff branch1 branch2 比较两个分支的差异 git merge branchname——————将branchname分支合并到当前所在分支 储存变更 git stash——————暂存文件的修改(切换分支前需要暂存，否则切换失败) git stash list——————查看暂存列表 git stash apply stash@num——————将暂存拉回(stash@{number}：暂存的名称) git stash drop stash@num——————删除对应的暂存 git stash pop stash@num——————拉回暂存状态并删除暂存(相当于apply和drop的结合) Git远程仓库github上的仓库 创建仓库 clone——————克隆仓库到本地(相当于下载整个项目文件夹) push——————上项目文件传本地仓库 pull——————拉取所有项目文件到本地(公同管理项目，拉取项目文件) ignoring files 流程示例图： 代码示例：12345678910111213git clone https://github.com/xzbk/projects.git master 下载整个项目到本地git pull https://github.com/xzbk/projects.git master 将项目文件拉取到本地仓库中git push https://github.com/xzbk/projects.git master 将项目文件上传到远程仓库中git remote add github(名称) https://github.com/xzbk/projects.git(仓库地址) 给仓库地址取一个别名git remote remove github(名称) https://github.com/xzbk/projects.git(仓库地址) 删除远程仓库地址别名git remote -v 查看自己添加添加的软件仓库及名称git push(pull) github master 简化后 远程服务器上的仓库 用taskmanager来演示 git init --bare—————— git remote add name path—————— git remote rm name—————— git remote rename oldname newname—————— git fetch—————— Git ssh免秘钥登录 ssh-keygen——————获取ssh秘钥(公钥，在c/administrator/.ssh文件夹中) ssh-copy-id user@host——————将本机的公钥复制到远程服务器的authorized_keys文件中 如果不是自己的服务器可以将本地公钥发送给服务器管理员，添加爱authorized_keys中 Git的glob匹配模式 星号(*)匹配零个或多个任意字符 [abc]匹配任何一个列在括号中的字符 问号(?)只匹配一个人义字符 [0-9]、[a-z]匹配范围 Git跳过追踪 在项目目录下新建.gitignore文件 将要忽略的文件配置到.gitignore文件中 如果被忽略的文件刘改了，会自动提交到暂存区，需使用git rm --cached filename来使文件被忽略 1234例: .gitignore index.html index.* 也可以使用glob匹配模式进行配置 Git帮助文档的使用 git help——————查看帮助文档 git help command——————查看command命令的使用文档 帮助文档官方地址：https://git-scm.com/docs Git流程图]]></content>
      <categories>
        <category>关于技术的深入浅出</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入浅出]]></title>
    <url>%2F2018%2F05%2F11%2FJavaScript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%2F</url>
    <content type="text"><![CDATA[Javascript概述什么是javascript？ 解释性语言 Javascript是一种客户端语言，能够与用户进行交互，响应用户对浏览器的操作事件，嵌入到html页面中运行，能够做出特效。 为什么要学习JavaScript 动态效果实现，事件响应，样式改变，产生动画。 JavaScript 基础变量类型基本类型有 string———字符串 number———数字 Boolean———布尔 null———空值null undefined———就一个值就是undefined。未定义的（表示一个变量没有赋值，或者一个对象不存在某个属性）， object———对象 array———数组 基本函数 parseInt(string str) ———转成整数 parseFloat(string str) ———转成浮点数 eval———能够把里面字符串类型的参数转成表达式并计算出来，甚至里面可以放一段代码，eval———可以执行这段代码。 typeOf(obj) ———具体的值 根据该值返回相应的类型。类型就是上面列出的js的几种基本类型。 alert(‘content’) ———函数是弹出框，显示的内容是里面的参数值； 变量定义变量声明和定义123456&lt;script type="text/javascript"&gt; var str;//定义一个js变量，变量以var开头+变量名 str="hello";//赋值，赋值之后才确定了str的类型 str=0;//js语言是一个弱类型语言 alert(str);//在firebug控制台显示结果&lt;/script&gt; var name=””; 如果变量定义不写var表示定义的该变量是一个全局变量。 变量作用域：函数内定义的变量是局部变量，在函数之外定义的是全局变量，局部变量优先级大于全局变量的优先级 函数 定义方式：function 函数名(函数参数……){ 函数体;return 11;} 注意：形参只能写参数名称。1234567891011//定义函数function sum(n)&#123; var total=0; for(var i=1;i&lt;=n;i++)&#123;total+=i; &#125;return total;&#125;//调用函数var total=sum(1000);console.log('最后的结果是：'+total); 数组用法 var arr=[1,2,3,4]; ———定义和初始化 var arr=new Array();———定义一个空的数组，使用了js内置对象Array arr[i]———访问数组元素，i表示数组元素的下标，从0开始的 面向对象(自定义对象) 对象只是带有属性和方法的特殊数据类型。 创建新对象有两种不同的方法： 种方法： 123456789101112&lt;script type="text/javascript"&gt; &lt;!-- 自定义对象,并创建对象的实例 --&gt; var stu=new Object();//定义一个Object类型的对象 stu.name='xiaoming'; stu.age=22; stu.study=function()&#123;alert('this is a student!')&#125;; //访问学生的姓名 alert(stu.name); var stu1=new Object(); stu1.name='zhangsan'; alert(stu1.name); &lt;/script&gt; 另一种写法： 12var stu=&#123;name:”xiaoming”,”age”:22&#125;;Alert(stu.name) 内置对象String对象 创建一个String对象 12Var str=”hello”;Var str=new String(“hello”) 常用api strObj.length———显示字符串的长度 strObj.indexOf(‘sss’) ———获取子串在strObj中第一次出现的位置 strObj.concat(‘str’) ———字符串连接 strObj.replace(old,new) ———搜索old替换为new,第一个参数是搜索的模式，可以用正则表达式 数组对象 创建一个数组对象 123var cnweek=new Array(7);var books=new Array();var arr=[1,2,3,4]; 常用api： arrObj.join(‘连接符’) ———返回由连接符把数组连接起来的一个字符串。 arrObj.reverse()———函数代表反向目前的数组元素 `arrObj.sort() 对数组元素进行排序 arrObj.push(ele)———向数组末尾添加元素 arrObj.pop()———弹出数组尾部元素，返回值就是弹出的这个元素 arrObj.shift ———删除并返回数组的第一个元素 arrobj.unshift(ele1….elen) ———可向数组的开头添加一个或更多元素，并返回新的长度。 arrObj.slice(start,end) ———返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 arrObj.splice(index,howmany,element1,.....,elementX) ———方法用于插入、删除或替换数组的元素。 Date对象 定义一个date对象 var dte=new Date(); 常用api：123456789var year=dte.getFullYear();var month=dte.getMonth()+1;var date=dte.getDate();var day=dte.getDay();//0-6//定义一个数组存储周一到周日var dayarr=['周日','周一','周二','周三','周四','周五','周六'];var str='今天是'+year+'年'+month+'月'+date+'日， '+dayarr[day];console.log(str) &lt;/script&gt; JavaScript中级Javascript事件和函数绑定 给元素注册事件的几种方法： 直接在标签上定义事件并指定处理函数。 在js代码中用document.getElementById(“btn”).onclick = method1;（函数名称） 鼠标事件 Onmouseover,onmouseout———鼠标移动到元素上面和从元素离开 Onblur,onfocus———文本框等失去焦点和获取焦点 Onclick———点击 键盘事件 Onkeydown———键盘按下事件 Onkeyup———键盘松开 Onkeypress———按键动作 事件的对象event e.clientX,e.cientY———相对于浏览器窗口的坐标 e.screenX,e.screenY———相对于屏幕的坐标 e.offset,e.offset Y———相对于事件的触发对象的。只能用于ie 函数中的this This在java中表示当前对象，事件响应函数中亦是如此。点击了那个对象，哪个对象就是this。 如果在标签内通过onclick属性注册函数，this和event等对象均需要作为实参传递到函数。 如果通过btn.onclick=function方式，则不需要传递，函数内就可以直接使用event和this。 事件冒泡机制: 当处于DHTML对象模型底部对象事件发生时会依次激活上面对象定义的同类事件处理。 如何阻止冒泡： ie下面event.cancelBubble=true; firefoxf,chrome下面event.stopPropagation() JavaScript操作html文档元素DOM（文档对象模型）简单来说就是一个html网页的每个标签对应一个具体的对象，每个标签的属性看做所属标签对象的属性，这样整个html就是一棵由标签对象组成的对象树结构。如图：文档对象模型树结构图 DOM对象获取 document常用方法获取本网页元素 getElementById()———返回对拥有指定 id 的第一个对象的引用 getElementsByName()———返回带有指定名称的对象集合 getElementsByTagName()———返回带有指定标签名的对象集合。 关于节点（了解即可） 获取的某个元素叫做节点Node，节点一般有父节点和孩子节点，兄弟节点等，具体示意图如下： 节点所有孩子：children() 动态操作样式 表格隔行变色效果，斑马条纹实现 12345678910111213141516【实例代码】&lt;script type="text/javascript"&gt; function init()&#123; var trarr=document.getElementsByTagName('tr'); for(var i=0;i&lt;trarr.length;i++)&#123; if(i%2==0) &#123; trarr[i].style.backgroundColor='red' &#125; else&#123; trarr[i].style.backgroundColor='blue' &#125; &#125; 动态改变标签内的html内容 内容使用div的innerHTML属性来进行控制。 通过点击按钮，比如动态增加表格的一行。1234567【实例代码】function addrow()&#123; //给table里面拼接一个tr var tab=document.getElementById('tab');//得到table //改变table的innerHTML属性 tab.innerHTML=tab.innerHTML+'&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;222&lt;/td&gt;&lt;td&gt;333&lt;/td&gt;&lt;/tr&gt;';&#125; 定时器方法使用 第一种：window.setInterval(函数名称，毫秒数) 设置定时器inter = window.setInterval(function(){...},5000); 清除定时器Window.clearInterval(inter) 第二种：window.setTimeout(函数名称，毫秒数) 不循环执行，执行一次 设置定时器inter = window.setTimeout(function(){}，1000) 清除定时器：window.clearTimeout(inter) 时钟代码示例：12345678910function f()&#123; var dte=new Date(); var str=dte.toLocaleString(); document.getElementById('clocktxt').innerHTML=str;&#125;var timinter=setInterval(f,1000);//定时器function stop()&#123; clearInterval(timinter);&#125; Browser对象 Window———层级中的顶层对象，表示浏览器窗口。 Navigator———包含客户端浏览器的信息。 Screen———包含客户端显示屏的信息。 History———包含了浏览器窗口访问过的 URL。 Location———包含了当前 URL 的信息。 重点介绍Window对象 打开窗口和关闭窗口 123456function openwin()&#123; window.open("http://www.baidu.com","百度","width=400,height=400,resizable=no"); &#125;function closewin()&#123; window.close();&#125; 代码实例：window.open(url, name,params); 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="Generator" content="EditPlus®"&gt; &lt;meta name="Author" content=""&gt; &lt;meta name="Keywords" content=""&gt; &lt;meta name="Description" content=""&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript"&gt; function newwin()&#123; window.open("http://www.baidu.com","newwin","width=200,height=200,resizable=no"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;welcome to oracle class!&lt;/h1&gt; &lt;input type="button" value="goto 课堂" onclick="newwin()" /&gt; &lt;/body&gt;&lt;/html&gt; 补充： Window.location———————-地址栏 如果要改变地址栏的地址，window.location.href=’http://www.baidu.com’; JavaScript高级关于数组自定义规则排序12345678910111213&lt;script type="text/javascript"&gt; //定义一个裁判，界定排序规则 function cmp(a,b)&#123; return a-b; &#125; var arr=[12,45,1,23,22,123]; console.log(arr.join()); //排序 arr.sort(cmp); console.log(arr.join());&lt;/script&gt; 正则表达式 什么是正则 定义：一串英文或者数字或者. + @ +一串英文，数字 ———自然语言 正则：就是自然语言的一个用计算机语言进行的描述 正则入门(两种写法) 第一种：var reg=new RegExp(描述) 第二种：var reg=/描述/[可选：i 忽略大小写,g 全局匹配,m多行匹配] 作用：匹配字符串 12345678&lt;script type="text/javascript"&gt;var str="hello oracle";//寻找o字符串var reg=/o/;//查看匹配结果var b=reg.test(str);//查看str字符串中是否有能够匹配reg这种描述的字符串alert(b)&lt;/script&gt; 总结：reg对象最重要的api：reg.test(str)———str表示要匹配的字符串，reg表示正则表达式。 返回值———是否匹配成功，是否在str中找到了reg。 如何书写正则 12345问题：给定一个字符串”abc 123 hello 56dddccc 78ssdks”,要求找到里面所有的数字。var str="abc 123 hello 56dddccc 78ssdks"; //是否包含数字 var reg=/[0-9]/g;str.match()//返回的是所有匹配的结果，因为可选参数g。 量词，匹配多个字符 1234567&lt;script type="text/javascript"&gt; var str="abc 123 hello 56dddcDDcc 78ssdks"; //显示所有的单词 var reg=/[a-z]+/ig; var arr=str.match(reg); alert(arr.join()) &lt;/script&gt; 书写一些基本的表单验证 12345678910111213141516171819202122用户名必须为字母数字下划线：&lt;script type="text/javascript"&gt; function valid()&#123; var userele=document.getElementById('username'); var username=userele.value; if(username=='')&#123; alert('用户名不能为空') &#125; //只允许用户名为字母数字下划线 var reg=/^[a-z]+$/;//^表示开始位置，$表示结束位置 if(!reg.test(username))&#123; alert('用户名必须为字母数字下划线') &#125; //email 校验 ：一串英文或者数字或者. + @ +一串英文，数字 -----自然语言dianwei.chi@oraclewdp.com var emailele=document.getElementById('email'); var email=emailele.value; var emailreg=/^[a-z0-9.]+@[a-z0-9]+[.]+(com|cn|org)$/; if(!emailreg.test(email))&#123; alert('邮箱不合法') &#125; &#125; &lt;/script&gt; 常见正则表达式表示符号： 中括号： 含义：表示在方括号里面的集合中，任取一个。 量词： Js调试技巧 材料：Chrome浏览器 页面出错信息查看：F12查看开发者工具-console控制台 调试js程序 找到js脚本 在对应行打上断点 触发事件执行，进入断点对应脚本 观察自定义变量的值，改变当前程序行为 通过+，增加自定义变量观察。 在程序运行过程中，改变变量的当前值，改变程序运行轨迹。举例： jQuery框架（详见jQuery笔记）文档结构图]]></content>
      <categories>
        <category>关于技术的深入浅出</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery深入浅出]]></title>
    <url>%2F2018%2F05%2F08%2FjQuery%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%2F</url>
    <content type="text"><![CDATA[引入jquery 什么是jquery？ jQuery 是一个 JavaScript 库。是一个“写的更少，但做的更多”的轻量级 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程。 下载和引用 下载jQuery http://jquery.com提供了最新的jQuery框架下载。通常只需下载最小的jQuery包。 页面引用 将jQuery框架文件导入后，就可以使用jQuery的选择器和各种函数功能了 Jquery函数库包含以下特性： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX jQuery使用步骤： 首先web项目引入js包。jQuery-2.0.3.min.js 页面导入js， 书写自己的js脚本，在js脚本中使用jQuery的选择器和函数。 Jquery基本选择器 属性选择器 层级选择器 过滤选择器 表单选择器 被选中选择器 Jquery函数Dom对象和jQuery对象转换 Dom对象和jquery对象 二者不能互相调用对方的方法和属性，可以用dom对象直接构建一个jquery对象 比如： 12 var div = document.getElementById(“testDiv”);  var jQueryObject = $(div); 也可以通过选择器直接构建 Jquery对象转dom对象 源于jquery对象时一个数组1234567 jQuery对象是一个数组对象，可以通过[index]的方法，来得到相应的DOM对象  $username = $(“#username”); return $username[0]; jQuery本身提供，通过.get(index)方法，得到相应的DOM对象  $username = $(“#username”); return $username.get(0); Jquery函数之核心函数123456789$(html) 根据提供的原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 HTML 元素$(elements) 将一个或多个DOM元素转化为jQuery对象 $(selector) 根据表达式（selector）来查找所有匹配的元素 $(callback) 当页面元素加载完成后，执行函数callbackCallback:这是一个回调函数，表示外函数执行完毕之后才回去调用这个函数。 访问jQuery对象123456789each(callback) 遍历对象，并循环执行指定的函数 size()和length 对象中元素的个数 get()和get(index) 把 jQuery 对象转换为 DOM 对象 index(subject) 对象中subject的索引值 eq(index) 返回下表为index的元素，注意该对象是jq对象。 操作元素的属性1234attr(‘src’) 获取jQuery对象中第一个元素的对应属性值 attr(&#123; src: "test.jpg", alt: "Test Image" &#125;) 为jQuery对象同时定义多个属性 attr(key,value) 为jQuery对象定义属性并赋值 removeAttr(‘height’) 移除jQuery对象内指定属性 操作元素的内容和值12345678910 操作第一个匹配元素的html内容: html() html(val) 操作元素的内容: text() text(val) 操作元素的当前值 : val() val(val) val(array) 操作元素style属性包含的样式12345678操作元素的样式： css(name) css(&#123;color: "#ff0011", background: "blue"&#125;) css(name,value)操作元素class属性： addClass(class) removeClass(class) toggleClass(class) 文档操作函数123456789101112131415append(content)—在本元素内部的最后一个子元素后面添加appendTo(content)—加到父元素的最后一个子元素的后面prepend(content)—再本元素的内部的第一个元素的前面添加prependTo(content)—加到父元素的第一个子元素的前面after(content)before(content)insertAfter(content)insertBefore(content)----在同级别的元素之前添加 Jquery事件的绑定与取消 第一种注册方式 12345bind() 为每一个匹配元素的特定事件绑定一个事件处理器函数 unbind() 删除绑定事件 one 用法和bind相同，只是该事件只执行一次，执行完之后处理程序就会自动删除 第二种注册事件方式 12345678910111213$(":button:eq(0)").click(function()&#123; alert($(this).val());&#125;);$(":button:eq(1)").click(function()&#123; alert($(this).val());&#125;);//鼠标移动到按钮上背景色红色，mouseover,mouseout$(":button:eq(0)").mouseover(function()&#123; $(this).css("background","red");&#125;);$(":button:eq(0)").mouseout(function()&#123; $(this).css("background","");&#125;); Jquery动画函数Jquery基本动画1234567891011 $("div").hide();//隐藏 $("div").hide(1000);//隐藏，历时1秒 $("div").show();//显示 $("div").show(1000);//显示，历时1秒 $(“div”).toggle();//切换  $(“div”).toggle(1000);//切换，历时1秒 滑动动画123slideDown(speed,callback) 可以把隐藏元素以滑动的效果显示出来slideUp(speed,callback) 以滑动的效果隐藏 淡入淡出12345fadeIn(speed,[callback]) 通过透明度的变化实现元素的淡入效果fadeOut(speed,[callback]) 通过透明度的变化实现元素的淡出效果其他函数：比如children(),parent(),next() Jquery请求ajax典型方法123456789101112131415&lt;script language="javascript" type="text/javascript"&gt;$.ajax(&#123; url:'/MyAjax/ajaxServlet', type:'get', data:&#123;username:username&#125;,//&#123;username:"xiaoming"&#125; dataType:'text', success:function(data)&#123; alert(data) &#125;, error:function()&#123; &#125; &#125;);&lt;/script&gt; 参数说明 文档结构图]]></content>
      <categories>
        <category>关于技术的深入浅出</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tableParameter]]></title>
    <url>%2F2018%2F04%2F13%2FtableParameter%2F</url>
    <content type="text"><![CDATA[参数 详细解释 -l 以长列表方式显示（显示出文件/文件夹详细信息） -t 按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） -r 逆序排列 -: 右对齐 :- 左对齐 :-: 中间对齐]]></content>
      <categories>
        <category>入门</category>
      </categories>
      <tags>
        <tag>helloword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令简记]]></title>
    <url>%2F2018%2F04%2F09%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Linux基本操作命令行bash的基本操作提示符123$ 普通用户提示符# 超级用户提示符 命令一般有三部分组成12345命令选项参数 bash基本命令12345678910111213141516171819202122232425init 3 图形界面转换成命令界面init 5 命令界面转换成图形界面which ls 查看命令的绝对路径id 显示当前用户信息passwd 修改当前用户密码uname [-a] 查看当前用户信息[所有信息]hostname 查看当前主机名ls 列出当前目录所有的文件ctrl+c 终止当前命令tab 自动补全(文件名)history 查看历史记录crtrl+r 在历史记录中搜索命令↑ 返回上一个命令 超级用户切换12345su - 切换到root超级用户(并使用一个新的运行环境)exit 退出超级用户sudo 使用管理员用户身份运行命令 管理后台作业123456789命令 &amp; 将命令放到后台运行jobs 查看后台作业bg 将作业在后台继续运行fg 将作业拿到前台运行ctrl+z 暂停某个程序 文件系统的基本结构当前工作目录1pwd 显示当前工作目录 列出目录内容1234567ls -a 显示所有文件(包括隐藏文件)ls -l 显示详细信息ls -R 递归显示子目录结构ls -ld 显示目录和链接信息 查看文件类型1file 查看文件的类型 文件基本操作管理复制文件、目录12345cp 源文件(文件夹) 目标文件(文件夹)cp -r 递归复制文件或目录cp -v 显示详细信息 移动、重命名文件或目录12345mv 文件 目标目录• 如果指定文件名，则可以重命名文件例:mv file file1 如果没有file1目录即为将file文件重命名 创建、删除文件123456789touch 创建一个空白文件或者更新已有文件rm 删除文件或目录(非空目录)rm -i 交互式删除(每删除一个都要确认)rm -r 递归删除包括目录中的所有内容rm -f 强制删除，没有提示(谨慎使用) 创建、删除目录12345mkdir 创建一个目录rmdir 删除一个空目录rm -r 删除一个非空目录 linux系统目录架构123456789101112131415161718192021222324252627• /bin：bin是Binary的缩写。这个目录存放着普通用户经常使用的命令文件。• /sbin：s就是Super User的意思。这里存放的是系统管理员使用的系统管理程序。• /boot：这里存放的是启动Linux时使用的一些核心文件，包括内核、一些链接文件以及镜像文件。• /dev：dev是Device(设备)的缩写。该目录下存放的是设备文件，在Linux中访问外部设备的方式和访问文件的方式是相同的。• /proc：这个目录是一个虚拟的目录，它是系统内存的映射。我们可以通过直接访问这个目录来获取系统信息。• /etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。• /lib：这个目录里存放着系统最基本的动态链接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。• /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。• /mnt 在这里面有几个目录，系统提供这些目录是为了让用户临时挂载别的文件系统，我们可以将光驱挂载在/mnt/cdrom上，然后进入该目录就可以查看光驱里的内容了。• /root：该目录为系统管理员（即超级用户root）的用户主目录。• /home：用以存放普通用户的主目录。在Linux中，每个用户都有一个自己的目录，一般以用户的账号命名。• /var：这个目录中存放着在不断更新的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种缓冲区和日志文件。• /tmp：这个目录是用来存放一些临时文件的。• /usr：我们要用到的很多应用程序和文件几乎都存放在usr目录下。如：/usr/local：这是提供给一般用户的/usr目录，在这里安装一般的应用软件。 linux系统常用命令日期时间12345678date 查看、设置当前系统时间 格式化显示时间：+%Y--%m--%dhwclock 显示硬件时钟时间(clock)cal 查看日历uptime 查看系统运行时间 输出、查看命令123456789101112echo 显示输入的内容cat 显示文件内容head -n 显示文件的投几行(默认10行)tail -n 显示文件的末尾几行(默认10行) -f 追踪文件的更新(一般用于查看日志，命令不会退出，会持续显示更新内容)more 翻页显示文件内容(只能向下翻页,空格键翻页)less 用于反也显示文件内容(带上下翻页,空格键翻页,q退出) 查看硬件信息12345lspci -v 查看PCI设备lsusb -v 查看USB设备lsmod 查看加载的模块(驱动) 关机、重启123456789101112shutdown [关机、重启] 时间 -h 关闭计算机 -r 重启计算机例： 立即关机 shutdown -h now 10分钟后关机 shutdown -h +10 23:30关机 shutdown -h 23:30 立即重启 shutdown -r nowpoweroff 立即关机reboot 立即重启 归档、压缩12345678910zip 压缩文件(zip 压缩后文件名 原始文件 → zip linux.zip file)unzip 解压缩zip文件gzip 压缩文件tar 归档(打包)文件(tar out.tar file) -cvf 创建一个归档 -xvf 释放一个归档 -cvzf 归档并压缩(tar -cvzf newfilename.tar.gz file) 查找1234567891011121314151617locate 快速查找文件、文件夹find 高级查找文件、文件夹(find 查找位置 查找参数)常用的查找条件如下： -name -perm -user -group -ctime -type -size 例： find . -name *linux* 在当前目录基于文件名查找包含linux的文件 find / -name *.conf find / -perm 777 在根分区下查找所有权限是777的文件 find / -type d 查找所有的目录类型的文件 find . -name "a*" -exec ls -l &#123;&#125; \; 用查找结果执行命令 vi文本编辑器vim1234567vim 启动文本编辑器• 使用 vim+目标文件路径 的形式使用vim• 如果目标文件存在，vim打开该文件• 如果目标文件不存在，则vim新建并打开该文件 vim有三种模式1234567- 命令模式(常规模式) 按下Esc键返回该模式 该模式下按下 i 键即可进入插入模式 按下 ： 键可进入ex模式- 插入模式 该模式下可以输入编辑文本内容- ex模式 该模式下可以保存修改或退出vim vim命令模式1234567891011121314151617i 在光标前插入文本o 在当前行下面插入新行 dd 删除整行yy 复制当前行nyy 复制n行p 粘贴u 撤销上一个操作r 替换当前字符/ 查找关键字 ex模式12345678910111213:w 保存当前修改:q 退出:q! 强制退出，不保存修改:x 保存并退出，相当于:wq:set number 显示行号:! 系统命令 执行一个系统命令并显示结果:sh 切换到命令行，使用ctrl+d切换回vim Linux磁盘及文件系统管理使用fdisk进行磁盘管理fdisk分区(分区后并不能直接使用，需要在其上建立文件系统才可使用)123456789fdisk 超级用户权限的分区命令fdisk -l 列出所有安装的磁盘及其分区信息fdisk /dev/sda可以对目标磁盘进行分区操作(必须输入参数w后才会保存并退出)partprobe 分区之后需要使用该命令使内核更新分区信息，否则可能需要重启才能识别新的分区 proc/partitions 此文件也可以用来查看分区信息 linux文件系统mke2fs(创建好文件系统后，需要挂在到一个目录才能使用)12345678910mke2fs -t ext4 /dev/sda3 用来创建文件系统命令常用参数:-b blocksize 指定文件系统块大小-c 建立文件系统时检查坏损块-L label 指定卷标-j 建立文件系统日志 mkfs(创建文件系统，相对于mke2fs，参数较少)12345mkfs.ext3 /dev/sda3mkfs.ext4 /dev/sda3mkfs.vfat /dev/sda3 dumpe2fs1dumpe2fs /dev/sda2 查看分区文件系统信息 e2label(标签一般都大写)12345e2label 为文件系统添加标签e2label /dev/sda2 显示sda2的系统标签e2label /dev/sda2 H 将 sda2 的系统标签设置为 H fsck123456789fsck /dev/sda2 检查并修复损坏的文件系统• 使用-y参数不提示而直接进行修复 • 默认fsck会自动判断文件系统类型，如果损坏严重，用-t参数指定文件系统类型• 识别为文件的损坏数据，fsck会将该文件放入lost+fond目录中• 系统启动时会对磁盘进行fsck操作 linux文件系统挂载管理mount1234567891011121314151617mount /dev/sda3 /mnt 将分区sda3挂载到mnt目录下mount 不带任何参数为显示所有已经挂载了的文件系统 选项: -t 指定文件系统的类型 -o 指定挂载参数 参数: ro,rw 以只读或读写形式挂载,默认是rw sync 代表不使用缓存，而是对所有操作直接写入磁盘 async 代表使用缓存，默认是async noatime 代表每次访问文件时不更新文件的访问时间 atime 代表每次访问文件时更新文件访问时间 remount 重新挂载文件系统 umount123456789umount 用来卸载已经挂在的文件系统(相当于windows的弹出)unmount /dev/sda3(挂载点) = umount /mnt(挂载目录)• 如果出现device is busy报错，表示该文件正在被使用，无法卸载，可使用一下命令查看进程fuser -m /mnt(挂载点) 查看文件系统的进程lsof /mnt/(挂载目录) 查看正在被使用的文件 自动挂载123• 配置文件/etc/fstab用来定义需要自动挂载的文件系统，fstab中每一行代表一个挂载配置，• 格式如下: 需要挂载的设备 挂载点 文件系统 挂载选项 dump、fsdk相关参数 /dev/sda3 /mnt ext4 defaults 0 0 123• 需要挂在的设备也可以用LABEL进行识别，使用LABEL=H取代/dev/sda3• mount -a 命令会挂载所有fstab中定义的自动挂载项 Linux下获取帮助linux下获取帮助(查看命令用q退出)help1• 几乎所有的命令都可以使用h或--help参数获取使用方法、参数、信息等 man(最常用的方式)123• man命令使linux中最常用的帮助命令，将要获取帮助的命令作为参数运行man命令就可以获取相应的文档帮助，例如：man ls• man文档分为很多类型:(可以这样在某一类型的文档中查找：man 2 ls) 部分 类型 1 用户命令 2 内核系统调用 3 库函数 4 特殊文件和设备 5 文件格式和规范 6 游戏 7 规范、标准和其他页面 8 系统管理命令 9 linux内核api 1man -k 关键字 该命令用来查询包含该关键字的文档 info(比man更为详细的查看方式)123• info与man类似，但是提供的信息更为详细深入，以类似网页的形式显示• man与info都可以通过“/+关键字”方式进行搜索 doc(比起前两种更为详尽)1• 很多程序、命令都有详尽的文档，以txt、html、pdf等方式保存在/usr/share/doc目录中，这些文档是相应程序最为详尽的文档 用户权限基础linux用户基础用户、组1234567891011121314• 当我们使用linux时，需要以一个用户身份登录，一个进程也需要以一个用户的身份运行; 用户限制使用者或进程可以使用、不可以使用哪些资源• 组用来方便组织管理用户• 每个用户拥有一个UserID，操作系统实际使用的是用户ID，而非用户名• 每个用户属于一个主组，属于一个或多个附属组• 每个用户拥有一个GroupID• 每个进程以一个用户身份运行，并受该用户可访问的资源限制• 每个可登录用户拥有一个指定的shell(系统用户没有) 用户123456789101112• 用户ID为32位，从0开始，但是为了和老式系统兼容，用户ID限制在6000以下• 用户分为以下三种: -root用户 (ID为0的用户为root用户) -系统用户 (1-499) -普通用户 (500以上) • 系统中的文件都有一个所属用户及所属组• 使用id命令可以显示当前用户的信息• 使用passwd命令可以修改当前用户的密码 相关文件12345• /etc/passwd 保存用户信息• /etc/shadow 保存用户密码• /etc/group 保存组信息 查看登录的用户12345whoami 显示当前用户who 显示有哪些用户已经登录系统w 显示有哪些用户已经登录系统并且正在干什么 创建一个用户123456789101112131415161718 useradd username 创建一个用户 选项: -d 修改家目录 -s 修改登录shell -u 修改userid -g 修改主组 -G 修改附属组(最多31个，用","分割) passwd username 修改用户密码 id username 查看用户username信息• 该命令会执行以下操作: 1.在/etc/passwd中添加用户信息 2.如果使用passwd命令创建密码，则将密码保存在/etc/shadow中 3.为用户创建一个新的家目录/home/username 4.将/etc/skel中的文件复制到用户的家目录中 5.建立一个与用户用户名相同的组，新建用户默认属于这个同名组 修改用户信息123456789101112131415usernmod 选项 username 修改用户信息 选项: -l 新用户名 -u 新userid -d 用户家目录位置 -g 用户所属主组 -G 用户所属附属组 -L 锁定用户使其不能登录 -U 解除锁定 删除用户123userdel username 删除指定用户(保留用户的家目录)userdel -r username 删除指定用户(同时删除用户的家目录) 组12345• 每个组有一个组ID• 组信息保存在/etc/group中• 每个用户拥有一个主组，同时还可以拥有最多31个附属组 创建、修改、删除组1234567groupadd groupname 创建组groupmod -n newname oldname 修改组名groupmod -g newgid oldgid 修改组IDgroupdel groupname 删除组 linux权限机制权限123• 权限是操作系统用来限制对资源访问的机制，权限一般分为读、写、执行• 每个进程都是以某个用户的身份运行，所以进程的权限与该用户的权限一样 文件权限1• linux中，每个文件都拥有以下三种权限: 权限 对文件的影响 对目录的影响 r(读取) 可读文件内容 可列出目录内容 w(写入) 可以修改文件内容 可在目录中创建删除文件 x(执行) 可以作为命令执行 可以访问目录内容 1• 目录必须拥有x权限，否则无法查看其内容 UGO12345678910111213linux权限基于UGO模型进行控制:• U代表User，G代表Group，O代表Other• 每一个文件的权限基于UGO进行设置• 权限三个一组(rwx)，对应UGO分别设置• 每一个文件拥有一个所属用户和所属组，对应UG，不属于该文件所属用户或所属组的使用O权限ls -l 查看当前目录下文件的详细信息文件详细信息对应字段示意如下: • drwxr-xr-- 2 nash_su training 208 Otc 1 13:50 linuxcast.net drwxr-xr-- 2 nash_su training 208 Otc 1 13:50 linuxcast.net UGO 链接数量 U:所属用户 G:所属组 大小 时间 文件名 • drwxr-xr-- d rwx r-x r-- 文件类型 U权限 G权限 O权限 修改文件所属用户、组12345chown newowner filename 改变文件的所属用户 选项: -R 递归的修改目录下的所有文件的所属用户chgrp newgroup filename 改变文件的所属组 选项: -R 递归的修改目录下的所有文件的所属组 修改权限12345678910111213chmod 模式 文件 修改文件的权限• 模式格式如下: u、g、o分别代表用户、组、其他 a 可以只带ugo +、-代表加入或删除对应权限 r、w、x代表三种权限• 模式示例: chmod u+rw file chmod g-x file chmod go+r file chmod a-x file linux扩展权限默认权限1234567891011121314151617• 每一个终端都拥有一个umask属性，来确定新建文件、文件夹的默认权限• umask使用数字权限方式表示，如:002• 目录的默认权限是:777-umask• 文件的默认权限是:666-umask• 一般， 普通用户的默认umask是002 root用户的默认umask是022 • 对于普通用户： 新建文件的权限是：666-002 新建目录的权限是：777-002 umask [022] 用于查看[设置]mask的值 特殊权限1• 除了普通权限外，还有三个特殊权限: 权限 对文件的影响 对目录的影响 suid 以文件的所属用户身份执行，而非执行文件的用户 无 sgid 以文件所属组身份执行 在该目录中创建的任意新文件的所属组与该目录的所属组相同 sticky 无 对目录拥有写入权限的用户仅可以删除其拥有的文件，无法删除其用户所拥有的文件 设置特殊权限12345chmod u+s filename 设置suidchmod g+s filename 设置sgidchmod o+t filename 设置sticky Linux网络基本配置网络基础基本网络参数1234567891011121314• 要配置一个局域网通信的计算机 - IP地址 - 子网掩码 • 要配置一个跨网段通信的计算机 - IP地址 - 子网掩码 - 网关(路由器)• 需要配置一个可(用域名)上网的计算机 - IP地址 - 子网掩码 - 网关(路由器) - DNS(域名解析) linux网络基础配置以太网链接1234567891011• 在linux中，以太网接口比命名为：eth0、eth1等，0、1代表网卡编号• 通过lspci命令可以查看网卡硬件信息(如果是usb网卡，则可能需要使用lsusb命令)ifconfig [-a] 查看所有网络接口信息ifconfig eth0 查看特定网络接口信息ifup eth0 启用一个网络接口ifdown eth0 禁用一个网络接口 配置网络信息123setup 配置网络信息• 配置完成后，使用ifup启用网卡，并使用ifconfig命令查看信息 网络相关配置文件1234567891011• 网卡配置文件 /etc/sysconfig/network-scripts/ifcfg-eth0• 主机名配置文件 /etc/sysconfig/network • 静态主机名配置文件 /etc/hosts • DNS配置文件 /etc/resolv.conf 网络测试命令12345678910111213141516• 测试网络连通性: ping 192.168.1.1 ping www.linuxcast.net• 显示路由表: ip route• 追踪到达目标地址的网络路径: traceroute www.linuxcast.net• 测试DNS解析: host www.linuxcast.net dig www.linuxcast.net• 使用mtr进行网络质量测试(结合了traceroute和ping): mtr www.linuxcast.net 修改主机名123456• 实时修改主机名(重启后无效): hostname train.linuxcast.net(新主机名) • 永久性修改主机名(重启后生效): /etc/sysconfig/network HOSTNAME=train.linuxcast.net(新主机名) 故障排查12345678910111213• 先查看网络配置信息是否正确: - IP地址 - 子网掩码 - 网关 - DNS• 查看到达网关是否联通: ping 网关IP地址• 查看DNS解析是否正常: host ww.linuxcast.net host www.126.conm host www.douban.com Linux管道、重定向及文本处理linux多命令协作:管道及重定向管道和重定向123• linux的命令行为我们提供了管道和重定向机制，多命令协作就是通过管道和重定向完成的• 命令行shell的数据流有以下定义: 名称 说明 编号 默认 STDIN 标准输入 0 键盘 STDOUT 标准输出 1 终端 STDERR 标准错误 2 终端 123• 命令通过STDIN接收参数或数据，通过STDOUT输出结果或通过STDERR输出错误• 通过管道和重定向我们可以控制CLI的数据流 分类 关键字 定义 例子 ::: &gt; 将STDOUT重定向到文件(覆盖) echo linux &gt; outfile ; ls &gt; outfile ::: &gt;&gt; 将STDOUT重定向到文件(追加) echo linux &gt;&gt; outfile ; date &gt;&gt; outfile 重定向 2&gt; 将STDERR冲定向到文件(覆盖) ls nothere 2&gt; errout ::: 2&gt;&amp;1 将STDERR与STDOUT结合 ls nothere 2&gt;&amp;1 alloutput ::: &lt; 重定向STDIN grep linux &lt; /etc/passwd 管道 I(竖杠) 将一个命令的STDOUT作为另一个命令的STDIN ls -l I(竖杠) grep linux ; find / -user linux I(竖杠) grep Video 123• 管道通常用来组合不同的命令，以实现一个复杂的功能• 重定向通常用来保存某命令的输出信息或错误信息，可以用来记录执行结果或保存错误信息到一个指定的文件夹 linux命令行文本处理工具(仅仅将文本换一种格式打印到shell,并不会改变原文件内容)文件浏览123456789cat textfilename 查看文件内容more textfilename 以翻页形式查看文件内容(只能向下翻页)less textfilename 以翻页形式查看文件(可上下翻页)head textfilename 查看文件的开始10行(或者指定参数)tail textfilename 查看文件的结束10行(或者指定参数) 基于关键字的搜索123456789101112grep 'linux' textfilename 基于关键字搜索文本选项: -i 搜索的时候忽略大小写 -n 显示结果所在的行 -v 输出不带关键字的行 -Ax 在输出的时候包含结果所在行之后的指定行 -Bx 在输出的时候包含结果所在行之前的指定行例: grep 'linux' /etc/passwd find / -user linux | grep Video 基于列处理文本123456789cut -d: -f2 textfilename 基于列处理文本内容选项: -d 指定分割字符(默认是TAB) -f 指定输出的列号 -c 基于字符进行切割(cut -c2-6 /etc/passwd)例: cut -d: -f2 /etc/passwd grep linux /etc/passwd | cut -d: -f3 文本统计1234567wc textfilename 统计文本信息选项: -l 只统计行数 -w 只统计单词 -c 只统计字节数 -m 只统计字符数 文本排序123456789sort textfilename 对文本内容排序选项: -r 进行倒序排序 -n 基于数字进行排序 -f 忽略大小写 -u 删除重复行 -tc 使用c作为分隔符为列进行排序 -tx 当进行基于指定字符进行分割为列的排序时，x指定基于哪个列排序 删除重复行123sort -u textfilename 删除文本重复行uniq textfilename 删除重复的相邻行 文本的比较1234567diff linux linux-new 比较两个文件的区别选项: -i 忽略大小写 -b 忽略空格数量的变化 -u 统一显示比较信息(一般用以生成patch(补丁)文件) 例: diff -u linux ilinux-new &gt; final.patch 检查拼写12345aspell check(被检查单词) file(被检查文件) 显示检查英文拼写例: aspell check linux aspell list &lt; linux 处理文本内容123tr -d 'TMD' &lt; linux 删除关键字tr 'a-z' 'A-Z' &lt; linux 转换大小写(小写转换成大写) 搜索替换1234567sed 搜索并替换文本(结合正则使用)例: sed 's/linux/unix/g' linux 搜索所有的linux替换为unix sed 'l,50s/linux/unix/g' linux 只查找替换1-50行 sed -e 's/linux/unix/g' -e 'nash/jnash_su/g' linux 替换多个 sed -f sededit linux 用f选项调用文件(里面存着指令)执行替换 Linux启动详解linux系统启动详解系统启动流程123456BIOSMBR:Boot Code执行引导程序-GRUB加载内核执行initrunlevel 1 - BIOS12345• BIOS 基本输入输出系统，一般保存在主板上的BIOS芯片中• 计算机启动第一个运行的就是BIOS，BIOS负责检查硬件并且查找可启动的设备• 可启动的设备在BIOS设置中定义，如USB、CHROM、HD 2 - MBR123• BIOS找到可启动的设备后执行其引导代码• 引导代码为MBR的前446字节(MBR为521字节) 3 - GRUB1234567891011121314• Grub是现在linux使用的主流引导程序• 可以用来引导现在几乎所有的操作系统• Grub的相关文件保存在/boot/grub中• Grub配置文件为/boot/grub/grub.cong• 配置格式: title CentOS root (hd0,1) kernel /boot/vmlinuz-2.6.32-279.e16.1686 ro root=UUID=91065d4c-2553-4c0c-90f9-8c69cf62a011 initrd /boot/initrd.img 4 - KERNEL123456789101112• MBR的引导代码将负责找到并加载linux内核• linux内核保存在/boot/vmlinuz-2.6.32-279.e16.i686.img• 一般还会加载内核模块打包文件：/boot/initramfs-2.6.32-279.e16.i686.img• linux为保持kernel的精简将一些不常用的驱动、功能编译成为模块 在需要的时候动态加载，而这些模块将被打包存为一个initramgfs文件• 早期的linux使用initrd文件，initramfs是initrd的替代优化版本,比initrd更加节省空间、更加灵活• dmesg 命令可以查看本次启动内核时输出的信息 5 - INIT1234567891011121314151617181920• init时linux系统中运行的第一个进程• 调用/etc/rc.d/rc.sysinit负责对系统进行初始化，挂载文件系统，并且根据运行级别启动相应的服务• linux运行级别: - 0 关机 - 1 单用户模式 - 2 不带网络的多用户模式 - 3 多用模式 - 4 未使用 - 5 XII图形化模式 - 6 重新启动 • 可以通过/etc/inittab配置文件修改默认的运行级别• 每个级别对应的启动服务保存在/etc/rc.d/rc[0123456]中runlevel 命令可以显示当前及上一个运行级别init 命令可以改变当前的运行级别 单用户修改ROOT密码1234567• 为内核传递参数“1”(数字一)或“single”系统可进入单用户模式• 单用户模式下不启动任何服务• 单用户模式直接以root用户登录，并且不需要密码• 可以使用passwd修改root密码 GRUB加密1234• 通过grub.conf中的启动配置中加入如下参数即可对grub进行加密: password --md5 加密后的密码 • 加密后的密码可以通过grub-md5-crypt生成 Linux软件基础RPM软件包管理源代码形式1234567891011121314• 绝大多数开源软件都是直接以源代码形式发布• 源代码一般会被打包成tar.gz的归档压缩文件• 程序源代码需要编译成二进制形式之后才能够运行使用• 源代码基本编译流程: 1- ./configure 检查编译环境、相关的库文件以及配置参数并生成makefile 2- make 对源代码进行编译，声称可执行文件 3- make install 将生成的可执行文件安装到计算机中• 源代码形式的软件使用起来较为麻烦，但是兼容性及可控制性较好• 开源软件一般都会大量使用其他开源软件的功能，所以开源软件会有大量的依赖关系(使用某软件需要先安装其他软件) RPM12345678910111213141516171819202122232425262728293031• 源代码形式的缺点：操作复杂、编译时间较长、极容易出现错误• 源代码形式的优点：适用于所有系统、可定制• RPM通过将源代码基于特定的平台系统编译成可执行的文件，并保存依赖关系，来简化开源软件的安装管理• RPM的设计目标： - 使用简单 - 使用单一软件包格式文件发布(rpm文件) - 可升级 - 追踪软件依赖关系 - 基本信息查询 - 软件验证功能 - 支持多平台• RPM软件包常用的命名规范： linux-1.2.0-30.el6.i686.rmp• RPM基础命令: rpm -i software.rpm 安装软件 rpm -e software.rpm 卸载软件 rpm -U software-new.rpm 升级形式安装 rpm -ivh http:..... 通过http、ftp协议安装软件 选项： -v 显示详细信息 -h 显示进度条 RPM12345678910111213• RPM会保存软件相关的很多信息，可以通过以下命令查询：rpm -qa 列出所有安装的rpm软件rpm -qf filename 查询目标文件属于哪一个rpm包rpm -qi packagename 查询指定已安装rpm软件的信息rpm -ql packagename 查询指定已安装rpm软件包含的文件rpm -qip software.rpm 查询rpm文件的信息rpm -qlp software.rpm 查询rpm文件包含的文件 RPM验证123456789101112• 软件在传播的过程中可能会被恶意的修改，所以为了安全起见现代系统都加入了对软件的验证功能• 验证一般使用非对称加密算法，所以需要一个秘钥• 导入秘钥： rpm --import RPM-GPG-KEY-CentOS-6• 验证rpm文件： rpm -K software.rpm • 验证已安装的软件： rpm -V software YUM软件管理YUM123456789101112131415• YUM是一个RPM的前端程序，主要目的是设计用来自动解决RPM的依赖关系问题• 特点如下： -自动解决依赖关系 -可以对RPM进行分组，并基于组进项安装操作 -引入仓库概念，支持多个仓库 -配置简单• YUM引入了仓库的概念• 仓库可以是本地的，也可以通过HTTP、FTP或NFS行是使用集中的、统一的网络仓库 YUM仓库1234567891011121314• YUM使用仓库保存管理rpm软件包，仓库的配置文件保存在/etc/yum.repos.d/目录下，格式如下： [linux](仓库名) name = this is the decoration of the repo baseurl = http://linux/..... enabled = 1 gpgcheck = 1 • 仓库可以使用file、http、ftp、nfs方式• yum配置文件必须以.repo结尾• 一个配置文件内可以保存多个仓库的配置信息• /etc/yum.repos.d/目录下可以存在多个配置文件 YUM基本命令1234567• yum管理软件常用的命令：yum install softwarename 安装指定软件yum remove softwarename 卸载指定软件yum update softwarename 升级指定软件 YUM查询123456789• 通过以下命令使用yum进行查询操作：yumn search keyword 搜索yum list (all | install recent | updates) 列出全部、安装的、最近的、软件更新yum ingo packagename 显示指定软件的信息yum whatprovides filename 查询目标文件属于哪个软件 创建RUM仓库12345678910• 可以通过以下方式手工创建yum仓库： 1. 将所有rpm文件拷贝到一个文件夹中 2. 通过rpm命令手工安装createrepo软件 3. 运行命令createrepo -v/rpm-directory 4. 若果有分组信息，则在运行命令的时候使用-g参数指定分组文件 creaerepo -g /tmp/*comps.xml/rpm-directory CentOS/RHEL的分组信息保存在光盘的repodata/目录下，文件名以comps.xml结尾的文件• 创建好后本机可以通过file方式直接使用 YUM CLEAN12345• yum为了提高速会缓存很多信息，但是有时候缓存会造成一些故障，可以通过以下命令来清楚缓存： yum clean all• 每次运行安装或查询类命令会重建yum缓存 布署项目相关命令service命令1234567• service命令可以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态• 服务的位置在/etc/init.d/目录下service servicename start/stop/restart 开启、关闭、重启servicename服务service servicename status 查看servicename服务的状态 ps命令12345• ps命令用于报告当前系统的进程状态,可以搭配kill指令随时中断、删除不必要的程序ps -a 显示所有终端上的进程，包括其他用户ps -u uid/username 显示所有与用户相关的进程信息 kill命令12345• kill命令用于杀死进程kill -9 324 杀死pid为324的进程killall inetd 杀死名字为inetd的进程 chkconfig命令1234567891011121314151617181920212223242526• chkconfig命令检查、设置系统的各种服务，它可查询操作系统在每一个执行等级中会执行哪些系统服务• 等级代号: -等级0表示：表示关机 -等级1表示：单用户模式 -等级2表示：无网络连接的多用户命令行模式 -等级3表示：有网络连接的多用户命令行模式 -等级4表示：不可用 -等级5表示：带图形界面的多用户模式 -等级6表示：重新启动chkconfig --list 列出所有的系统服务chkconfig --add httpd 增加httpd服务chkconfig --del httpd 删除httpd服务chkconfig --level httpd 2345 on 设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态chkconfig --list 列出系统所有的服务启动情况chkconfig --list mysqld 列出mysqld服务设置情况chkconfig --level 35 mysqld on 设定mysqld在等级3和5为开机运行服务，--level 35表示操作只在等级3和5执行，on表示启动，off表示关闭chkconfig mysqld on 设定mysqld在各等级为on，“各等级”包括2、3、4、5等级 source命令12345678910• source 命令可以强行让一个脚本去立即影响当前的环境• source 命令的另一种写法是点符号，用法和source相同• source 命令通常用于重新执行刚修改的初始化文件• 例: source filename .filename sh命令123456• 例如启动tomcat: sh startup.sh ./startup.sh netstat命令1234567• netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况netstat -a 列出所有端口netstat -ap 查看所有的信息netstat -an | grep ':80' 找出运行在指定端口的进程 ln命令123456789• ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种• 默认的连接类型是硬连接,如果要创建符号连接必须使用"-s"选项• 符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的ln sourcefile targetfile 创建硬链接ln sourcefile targetfile 创建软链接 weget命令1234567891011• wget命令用来从指定的URL下载文件• wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性• 如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕• 如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载• 对从那些限定了链接时间的服务器上下载大文件非常有用wget -v http://www.linuxde.net/testfile.zip 从指定url下载文件(-v:显示详细的执行过程)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo yilia主题添加背景音乐播放器]]></title>
    <url>%2F2018%2F04%2F05%2Fhexo-yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[添加音乐添加的网易云音乐，很方便。打开网易云音乐某首歌详情页，点击生成外链播放器，选择iframe插件。选择好尺寸。复制html代码。如： 1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&amp;id=4940455&amp;auto=1&amp;height=32"&gt;&lt;/iframe&gt; 这里手动修改width为”100%”,再添上class。然后把下面这段代码复制到themes\yilia\layout\_partial\left-col.ejs里，代码： 123&lt;nav class="header-music"&gt;&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&amp;id=4940455&amp;auto=1&amp;height=32"&gt;&lt;/iframe&gt;&lt;/nav&gt; 这样就可以生成播放器了，但是还需要调一下css样式。在themes\yilia\source\main.2d7529.css(如果名字不同，也应为main.xx.css)末尾添加1.header-music &#123;margin-top: 80px; &#125; 接着hexo clean,hexo g,hexo s搞定。]]></content>
      <categories>
        <category>主题相关</category>
      </categories>
      <tags>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Beginer's Temple]]></title>
    <url>%2F2018%2F04%2F04%2FBeginer-s-Temple%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment create a table 参数 详细解释 备注 -l use a long listing format 以长列表方式显示（显示出文件/文件夹详细信息） -t sort by modification time 按照修改时间排序（默认最近被修改的文件/文件夹排在最前面） -r reverse order while sorting 逆序排列]]></content>
      <categories>
        <category>入门</category>
      </categories>
      <tags>
        <tag>helloword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo yila添加文章阅读量统计]]></title>
    <url>%2F2018%2F04%2F04%2Fhexo-yila%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[引入不蒜子1&lt;script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 添加文章访问量将下面这段代码添加在/themes/yilia/layout/_partial/article.ejs的header的日期后面： 12345$ &lt;% if ( !index )&#123; %&gt; &lt;span class="archive-article-date"&gt; 阅读量 &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt; &lt;/span&gt;&lt;% &#125; %&gt;]]></content>
      <categories>
        <category>主题相关</category>
      </categories>
      <tags>
        <tag>yilia</tag>
      </tags>
  </entry>
</search>
